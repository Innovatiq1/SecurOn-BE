import cveModel from '../model/cveSchema.js';
import axios from "axios";
import User from '../model/userSchema.js';
import logger from '../helpers/loggers.js'; // Use ES module import

import moment from 'moment'
const currentTime = moment().format('YYYY-MM-DDTHH:mm:ss.SSSZ');

export const RunCveScheduler = async () => {
  logger.info(`Process started to sync CVE's from NIST`)
  var dateTime = new Date();
  //var month = ("0" +(dateTime.getMonth() + 1)).slice(-2);
  var month = (dateTime.getMonth() + 1).toString().padStart(2, '0');
  let date = ("0" + dateTime.getDate()).slice(-2);
  var year = dateTime.getFullYear();

  // var ppubSttartDate = 2023 + "-" + 10 + "-" + "0" + 1 + "T00:00:00.000";
  // var pubEndDate = year + "-" + month + "-" + date + "T23:59:59.000";


  var ppubSttartDate =year+"-"+month+"-"+date+"T00:00:00.000";
  var pubEndDate =year+"-"+month+"-"+date+"T23:59:59.000";
  const url = 'https://services.nvd.nist.gov/rest/json/cves/2.0/?pubStartDate=2025-05-01T00:00:00.000&pubEndDate=2025-05-30T23:59:59.000'

  // const url = 'https://services.nvd.nist.gov/rest/json/cves/2.0/?pubStartDate='+ppubSttartDate+'&pubEndDate='+pubEndDate;
  
  
  axios.get(
    url,
    { headers: { 'apikey': '2d3a2cf2-1934-4620-bce2-f69b9e5dfb43' } })


    .then(response => {

      let cveDetails = response.data;
      logger.info('Successfully accessed the NIST API')
      logger.info(`Fetched ${cveDetails.vulnerabilities.length} CVE records from the NIST API`)

      cveDetails.vulnerabilities.forEach((cveData) => {
        const metrcis = cveData.cve.metrics;
        let severity = "";

        let cveDataCopy = { ...cveData.cveDetails };

        if (Object.keys(metrcis).length > 0) {


          const filteredMetrics = [];
          Object.keys(metrcis).forEach((key) => {
            const sortedMetrics = metrcis[key].sort((a, b) => (a.cvssData.baseScore < b.cvssData.baseScore) ? 1 : a.cvssData.baseScore > b.cvssData.baseScore ? -1 : 0);
            filteredMetrics.push(sortedMetrics[0])
          })

          const priorityMetric = filteredMetrics.sort((a, b) => (a.cvssData.baseScore < b.cvssData.baseScore) ? 1 : a.cvssData.baseScore > b.cvssData.baseScore ? -1 : 0)[0];

          cveDataCopy = {
            ...cveDataCopy,
            metrics: {
              [Object.keys(metrcis)[0]]: [{ ...priorityMetric }]
            }
          }
          severity = priorityMetric.cvssData.baseSeverity ?? priorityMetric.baseSeverity
          let saveCveData = {
            date: cveData.cve.published, cveId: cveData.cve.id, cveDetails: cveData,
            seviarity: severity, month: month, year: year, fix: 'N',cvssScore:priorityMetric.cvssData.baseScore 
          };
          cveModel.create(saveCveData);
        } else {
          let saveCveData = {
            date: cveData.cve.published, cveId: cveData.cve.id, cveDetails: cveData,
            seviarity: severity, month: month, year: year, fix: 'N' ,cvssScore:0          
          };
          cveModel.create(saveCveData);
        }

      });
      logger.info(`Stored ${cveDetails.vulnerabilities.length} CVE records`)



    }).catch(error => {
      console.log(error);
      logger.error(`Got an error in accessing the NIST API: ${error.message}`);
    });
};

// export const getFilteredCves = async (request, response) => {
//   const { fromDate, toDate } = request.body;

//   // Define the predefined ranges
//   const ranges = [
//     [0, 1],
//     [1, 2],
//     [2, 3],
//     [3, 4],
//     [4, 5],
//     [5, 6],
//     [6, 7],
//     [7, 8],
//     [8, 9],
//     [9, ''],
//   ];

//   const buildDateRangeQuery = () => {
//     const formatDate = (date) => date.toISOString(); // Ensure proper format for MongoDB

//     if (!fromDate && !toDate) {
//       const currentDate = new Date();
//       const lastMonthDate = new Date();
//       lastMonthDate.setMonth(currentDate.getMonth() - 1);

//       return {
//         date: {
//           $gte: lastMonthDate,
//           $lte: currentDate,
//         },
//       };
//     } else {
//       return {
//         date: {
//           $gte: fromDate ? formatDate(new Date(fromDate)) : undefined,
//           $lte: toDate ? formatDate(new Date(toDate)) : undefined,
//         },
//       };
//     }
//   };

//   try {
//     const dateRangeQuery = buildDateRangeQuery();
//     const filterCves = {};

//     // Iterate through the ranges
//     for (const [min, max] of ranges) {
//       const cvssScoreQuery = {
//         cvssScore: {
//           ...(min !== '' ? { $gte: parseFloat(min) } : {}),
//           ...(max !== '' ? { $lt: parseFloat(max) } : {}),
//         },
//       };

//       const query = {
//         ...dateRangeQuery,
//         ...cvssScoreQuery,
//       };

//       // Fetch records for the current range
//       const filteredCves = await cveModel.find(query);

//       // Store the data in the filterCves object
//       const rangeKey = `${min}-${max === '' ? 'max' : max}`;
//       filterCves[rangeKey] = filteredCves;
//     }

//     // Respond with the aggregated data
//     response.status(200).json(filterCves);
//   } catch (error) {
//     console.error('Error fetching filtered CVEs', error);
//     response.status(500).json({ error: 'Error fetching filtered CVEs' });
//   }
// };

export const getFilteredCves = async (request, response) => {
  const { fromDate, toDate } = request.body;

  const buildDateRangeQuery = () => {
    if (!fromDate && !toDate) {
      const currentDate = new Date();
      const lastMonthDate = new Date();
      lastMonthDate.setMonth(currentDate.getMonth() - 1);

      return {
        $gte: lastMonthDate.toISOString(),
        $lte: currentDate.toISOString(),
      };
    } else {
      return {
        ...(fromDate ? { $gte: new Date(fromDate).toISOString() } : {}),
        ...(toDate ? { $lte: new Date(toDate).toISOString() } : {}),
      };
    }
  };

  try {
    const dateRangeQuery = buildDateRangeQuery();

    const ranges = [
      { min: 0, max: 1 },
      { min: 1, max: 2 },
      { min: 2, max: 3 },
      { min: 3, max: 4 },
      { min: 4, max: 5 },
      { min: 5, max: 6 },
      { min: 6, max: 7 },
      { min: 7, max: 8 },
      { min: 8, max: 9 },
      { min: 9, max: null }, 
    ];

    const aggregationPipeline = [
      { $match: { date: dateRangeQuery } },
      {
        $facet: ranges.reduce((facets, range) => {
          const rangeKey = `${range.min}-${range.max === null ? 'max' : range.max}`;
          facets[rangeKey] = [
            {
              $match: {
                cvssScore: {
                  ...(range.min !== null ? { $gte: range.min } : {}),
                  ...(range.max !== null ? { $lt: range.max } : {}),
                },
              },
            },
            { $count: "count" },
          ];
          return facets;
        }, {}),
      },
    ];

    const results = await cveModel.aggregate(aggregationPipeline);

    const filterCves = {};
    for (const [range, data] of Object.entries(results[0])) {
      filterCves[range] = data.length > 0 ? data[0].count : 0;
    }

    response.status(200).json(filterCves);
  } catch (error) {
    console.error("Error fetching filtered CVEs", error);
    response.status(500).json({ error: "Error fetching filtered CVEs" });
  }
};


export const getNewUpdatedCves = async (request, response) => {
  try {
    const calculateDateRange = (daysAgo) => {
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(endDate.getDate() - daysAgo);

      return {
        $gte: startDate.toISOString(), 
        $lt: endDate.toISOString(),
      };
    };
    const dateRanges = {
      "last 1 day": calculateDateRange(1),
      "last 7 days": calculateDateRange(7),
      "last 30 days": calculateDateRange(30),
    };

    const aggregationPipeline = [
      {
        $facet: Object.entries(dateRanges).reduce((facets, [key, range]) => {
          facets[key] = [
            { $match: { date: range } },
            { $count: "count" }, 
          ];
          return facets;
        }, {}),
      },
    ];
    const aggregatedResults = await cveModel.aggregate(aggregationPipeline);

    const results = {};
    for (const [key, data] of Object.entries(aggregatedResults[0])) {
      results[key] = data.length > 0 ? data[0].count : 0; 
    }

    response.status(200).json(results);
  } catch (error) {
    console.error("Error fetching updated CVEs", error);
    response.status(500).json({ error: "Error fetching updated CVEs" });
  }
};

export const getCveCountByWeakness = async (request, response) => {
  const { fromDate, toDate } = request.body;
  const searchArray = [
    "CWE-79", "CWE-89", "CWE-22", "CWE-20", "CWE-352",
    "CWE-200", "CWE-601", "CWE-119", "CWE-98",
    "CWE-611", "CWE-918", "CWE-922"
  ];

  try {
    // Build date range filter with string-based dates
    const dateRangeQuery = {};
    if (fromDate) dateRangeQuery.$gte = new Date(fromDate).toISOString(); 
    if (toDate) dateRangeQuery.$lte = new Date(toDate).toISOString(); 

    console.log("Date Range Query:", dateRangeQuery);

    const aggregationPipeline = [
      {
        $match: {
          "cveDetails.cve.weaknesses.description.value": { $in: searchArray },
          ...(fromDate || toDate ? { date: dateRangeQuery } : {}),
        },
      },
      {
        $unwind: {
          path: "$cveDetails.cve.weaknesses.description", 
          preserveNullAndEmptyArrays: true, 
        },
      },
      {
        $match: {
          "cveDetails.cve.weaknesses.description.value": { $in: searchArray }, // Match after unwind
        },
      },
      {
        $group: {
          _id: "$cveDetails.cve.weaknesses.description.value", // Group by CWE code
          count: { $sum: 1 }, // Count occurrences
        },
      },
      {
        $match: {
          count: { $gt: 0 }, // Exclude entries with zero count
        },
      },
      {
        $project: {
          _id: 0,
          cwe: "$_id", 
          count: 1, 
        },
      },
    ];

    // Execute aggregation
    const results = await cveModel.aggregate(aggregationPipeline);
    console.log("Aggregation Results:", results);

    // Create a map of the results
    const resultMap = results.reduce((acc, { cwe, count }) => {
      acc[cwe] = count;
      return acc;
    }, {});
    const allCweCounts = searchArray.map(cwe => {
      return `${cwe}: ${resultMap[cwe] || 0}`; // If no count found, set it to 0
    }).join(", ");

    response.status(200).json({ data: allCweCounts });
  } catch (error) {
    console.error("Error fetching CVE counts by weakness", error);
    response.status(500).json({ error: "Error fetching CVE counts by weakness" });
  }
};


export const getCveRecordsByWeaknessAndDate = async (request, response) => {
  const { fromDate, toDate, cwe } = request.body;

  try {
    // Build date range filter
    const dateRangeQuery = {};
    if (fromDate) dateRangeQuery.$gte = new Date(fromDate).toISOString();
    if (toDate) dateRangeQuery.$lte = new Date(toDate).toISOString();

    console.log("Date Range Query:", dateRangeQuery);

    const matchQuery = {
      ...(fromDate || toDate ? { date: dateRangeQuery } : {}),
      ...(cwe ? { "cveDetails.cve.weaknesses.description.value": cwe } : {})
    };

    const aggregationPipeline = [
      {
        $match: matchQuery, // Match based on date and CWE
      },
      {
        $unwind: {
          path: "$cveDetails.cve.weaknesses.description",
          preserveNullAndEmptyArrays: true, // This ensures you get records even if the description is empty
        },
      },
      {
        $match: {
          ...(cwe ? { "cveDetails.cve.weaknesses.description.value": cwe } : {}),
        },
      },
      {
        $project: {
          date: 1,
          month: 1,
          year: 1,
          fix: 1,
          cveId: "$cveDetails.cve.id",
          descriptions: "$cveDetails.cve.descriptions",
          severity: "$severity", // Fixed typo here from "seviarity" to "severity"
          weaknesses: "$cveDetails.cve.weaknesses",
          metrics: "$cveDetails.cve.metrics"
        },
      },
    ];

    // Execute aggregation
    const results = await cveModel.aggregate(aggregationPipeline);
    console.log("Filtered Records:", results);

    response.status(200).json({ data: results });
  } catch (error) {
    console.error("Error fetching CVE records by weakness and date", error);
    response.status(500).json({ error: "Error fetching CVE records by weakness and date" });
  }
};



// export const getCveRecordsByWeaknessAndDate = async (request, response) => {
//   const { fromDate, toDate, cws } = request.body;

//   try {
//     // Build date range filter
//     const dateRangeQuery = {};
//     if (fromDate) dateRangeQuery.$gte = new Date(fromDate).toISOString();
//     if (toDate) dateRangeQuery.$lte = new Date(toDate).toISOString();

//     const aggregationPipeline = [
//       {
//         $match: {
//           date: fromDate || toDate ? dateRangeQuery : undefined,
//           "cveDetails.cve.weaknesses.description.value": cws,
//         },
//       },
//       {
//         $project: {
//           date: 1,
//           month: 1,
//           year: 1,
//           fix: 1,
//           cveId: "$cveDetails.cve.id",
//           descriptions: "$cveDetails.cve.descriptions",
//           severity: "$seviarity",
//           weaknesses: "$cveDetails.cve.weaknesses",
//           metrics: "$cveDetails.cve.metrics"
//         },
//       },
//     ];

//     // Execute aggregation
//     const results = await cveModel.aggregate(aggregationPipeline);

//     // Send the response
//     response.status(200).json({ data: results });
//   } catch (error) {
//     console.error("Error fetching CVE details with scores:", error);
//     response.status(500).json({ error: "Error fetching CVE details with scores" });
//   }
// };






export default RunCveScheduler;