
import InventoryModel from "../model/inventorySchema.js";
import vendorProductCveModel from "../model/vendorProductCveSchema.js";
import axios from "axios";
import OemCpeModel from "../model/oemProductsSchema.js";
import User from "../model/userSchema.js";
import {
  systemLogger,
  userActivityLogger,
  runAssetProductCveMappingSchedulerLogger,
} from "../helpers/loggers.js";
import rp from "request-promise";
import { createRequire } from "module"; // Allows usage of require in ES module
import { version } from "os";
const require = createRequire(import.meta.url);
const cheerio = require("cheerio");
export const RunAssetProductCveMappingScheduler = async (request, response) => {
  runAssetProductCveMappingSchedulerLogger.info(
    "Scheduler has started to fetch cves for uploaded assets"
  );

  try {
    const assets = await InventoryModel.find({});
    // console.log("pppp",Product)
    //  const assets = await InventoryModel.find({});
    let assetsCount = assets.length;
    let count = 0;
    for (const asset of assets) {
      count = count + 1;
      console.log("count", count);
      //let prod = asset.product ? asset.product: asset.partNo;
      let partNo = asset.partNo;
      let isOsType = false;
      let result;
      let checkVersion = false;
      let firmVersion;
      if (partNo) {
        let Product;
        let ProductPartNo = await OemCpeModel.findOne({
          title: partNo.toLowerCase(),
        });

        let oemList = ["Fortinet", "F5", "Solarwinds", "Microsoft"];

        if (!oemList.includes(asset.vendor)) {
          checkVersion = true;
        }
        if (checkVersion) {
          isOsType = true;

          if (
            asset.osType != null &&
            asset.osType != undefined &&
            asset.osType != ""
          ) {
            Product = await OemCpeModel.findOne({
              title: asset.osType.toLowerCase(),
              version: asset.firmwareVersion,
            });
          }
        } else {
          if (asset.firmwareVersion == null || asset.firmwareVersion == "-") {
            Product = await OemCpeModel.findOne({
              title: partNo.toLowerCase(),
              version: "-",
            });
          } else {
            if (!asset.firmwareVersion.includes(".")) {
              firmVersion = parseFloat(asset.firmwareVersion).toFixed(1);
            } else {
              firmVersion = asset.firmwareVersion;
            }

            Product = await OemCpeModel.findOne({
              title: partNo.toLowerCase(),
              version: firmVersion,
            });
          }
        }

        if (!Product) {
          isOsType = true;
          if (
            asset.osType != null &&
            asset.osType != undefined &&
            asset.osType != ""
          ) {
            Product = await OemCpeModel.findOne({
              title: asset.osType.toLowerCase(),
              version: firmVersion,
            });
          }
        }
        
        if (Product) {
          let url;
          if (Product.cpeName.includes("\\")) {
            const modifiedCpeName = Product.cpeName.replace(/\\/g, "%5C");

            url = `https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=${modifiedCpeName}`;
          } else {
            url = `https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=${Product.cpeName}`;
          }
          axios
            .get(url, {
              headers: {
                apikey: "2d3a2cf2-1934-4620-bce2-f69b9e5dfb43",
              },
            })

            .then((response) => {
              let cveDetails = response.data;

              let finalCves = [];
              let skipOem = false;
              let oemList = ["Fortinet", "F5", "Solarwinds", "Microsoft"];
              if (oemList.includes(asset.vendor)) {
                skipOem = true;
              }

              if (isOsType && !skipOem) {
                try {
                  let cpeName2 = Product.cpeName;
                  let cpeName = cpeName2.split(":");
                  cpeName = cpeName.slice(0, 6).join(":");
                  let cpeCriteria;
                  if (ProductPartNo != null) {
                    cpeCriteria = ProductPartNo.cpeName;
                  }

                  const response = cveDetails;
console.log("dot",response)
                  response.vulnerabilities.forEach((vulnerability) => {
                    cveEligibleCheck(
                      vulnerability,
                      cpeName,
                      cpeCriteria,
                      Product,
                      partNo,
                      asset
                    );
                  });
                } catch (error) {
                  runAssetProductCveMappingSchedulerLogger.error(error);
                  console.log(error);
                }
              } else {
                cveDetails.vulnerabilities.forEach(async (cveData) => {
                  let cve = await vendorProductCveModel.findOne({
                    cveId: cveData.cve.id,
                    vendorName: Product.oemName,
                    productName: Product.title,
                    version: Product.version,
                    osType: asset.osType,
                  });

                  if (cve) {
                    console.log("cveId already");
                  } else {
                    const metrcis = cveData.cve.metrics;
                    let severity = "";
                    
                    let cveDataCopy = {
                      ...cveData.cveDetails,
                    };

                    if (Object.keys(metrcis).length > 0) {
                      const filteredMetrics = [];
                      Object.keys(metrcis).forEach((key) => {
                        const sortedMetrics = metrcis[key].sort((a, b) =>
                          a.cvssData.baseScore < b.cvssData.baseScore
                            ? 1
                            : a.cvssData.baseScore > b.cvssData.baseScore
                            ? -1
                            : 0
                        );
                        filteredMetrics.push(sortedMetrics[0]);
                      });

                      const priorityMetric = filteredMetrics.sort((a, b) =>
                        a.cvssData.baseScore < b.cvssData.baseScore
                          ? 1
                          : a.cvssData.baseScore > b.cvssData.baseScore
                          ? -1
                          : 0
                      )[0];

                      cveDataCopy = {
                        ...cveDataCopy,
                        metrics: {
                          [Object.keys(metrcis)[0]]: [
                            {
                              ...priorityMetric,
                            },
                          ],
                        },
                      };
                      severity =
                        priorityMetric.cvssData.baseSeverity ??
                        priorityMetric.baseSeverity;
                        
                      let dateVal = cveData.cve.published;
                      let monthYear = dateVal.split("-", 2);
                      let month = monthYear[1];
                      let year = monthYear[0];

                      let fixedRelease = "";
                      let advisoryTitle = "";
                      let advisoryUrl = "";
                      let workarounds = "";
                      const scrapeCiscoPage = async () => {
                       
                        try {
                          if (asset.vendor == "Solarwinds") {
                            
                            // Fetch HTML content from the advisory URL
                            advisoryUrl = `https://www.solarwinds.com/trust-center/security-advisories/${cveData?.cve?.id}`;
                            const html = await rp(advisoryUrl);
                            if (html) {
                              const $ = cheerio.load(html);
                              advisoryTitle = $("h1").text().trim();
                              const fixedReleaseArray = $("h3")
                                .filter((i, el) =>
                                  $(el)
                                    .text()
                                    .toLowerCase()
                                    .includes("fixed software release")
                                )
                                .next("ul") // Navigate to the sibling <ul> element
                                .find("li") // Find all <li> elements under the <ul>
                                .map((i, el) => $(el).text().trim()) // Extract text content for each list item
                                .get(); // Convert to an array

                              // Convert the array to a string (comma-separated)
                              fixedRelease = fixedReleaseArray.join(", ");
                            }

                          
                          }
                          if (asset.vendor == "Microsoft") {
                            advisoryUrl = `https://msrc.microsoft.com/update-guide/vulnerability/${cveData?.cve?.id}`;
                        
                            try {
                                const html = await rp(advisoryUrl);
                                if (html) {
                                    const $ = cheerio.load(html);
                                    // Select the `h1` with the specific class
                                    advisoryTitle = $("h1.ms-fontWeight-semibold.css-199").text().trim();
                                }
                            } catch (error) {
                                console.error('Error fetching or parsing advisory URL:', error);
                            }
                        }
                        
                    
                          if (asset.vendor == "Fortinet") {
                            advisoryUrl = cveData?.cve?.references[0].url;
                            const html = await rp(advisoryUrl);
                            if (html) {
                              const $ = cheerio.load(html);
                              advisoryTitle = $("h1").text().trim();
                              // const fixedReleaseArray = $("h3")
                              // .filter((i, el) => $(el).text().toLowerCase().includes("solutions"))
                              // .next("ul") // Navigate to the sibling <ul> element
                              // .find("li") // Find all <li> elements under the <ul>
                              // .map((i, el) => $(el).text().trim()) // Extract text content for each list item
                              // .get(); // Convert to an array
                              fixedRelease = $("table")
                              .find("tbody tr") // Locate all table rows in the body
                              .first() // Get the first row
                              .find("td") // Locate all table cells in the row
                              .last() // Get the last cell (Solution column)
                              .text() // Extract its text content
                              .trim();
                        
                            console.log("First Solution:", fixedRelease);
                            // if (!fixedRelease) {
                            //   fixedRelease = $("h3")
                            //     .filter((i, el) =>
                            //       $(el)
                            //         .text()
                            //         .toLowerCase()
                            //         .includes("solutions")
                            //     )
                            //     .nextUntil("h3") // Select all sibling elements until the next <h3>
                            //     .map((i, el) => $(el).text().trim()) // Extract text content for each element
                            //     .get() // Convert to an array
                            //     .join("\n");}
                            
                            }

                          }
                          if (asset.vendor == "F5") {
                            const puppeteer = require('puppeteer');
                            const cheerio = require('cheerio');
                        
                            const matchingUrls = cveData?.cve?.references.filter(ref => ref.url.includes('my.f5.com'));
                            const advisoryUrl = matchingUrls?.[0]?.url || cveData?.cve?.references[0]?.url;
                        
                            // async function fetchAdvisoryDetails(url) {
                            //     try {
                            //         const browser = await puppeteer.launch({ headless: true });
                            //         const page = await browser.newPage();
                            //         await page.goto(url, { waitUntil: 'networkidle0' });
                            //         await page.waitForSelector('h1', { timeout: 10000 });
                            //         const html = await page.content();
                            //         if (!html) {
                            //           console.log('Failed to fetch page content.');
                            //           return;
                            //       }
                          
                            //         await browser.close();
                        
                            //         const $ = cheerio.load(html);
                        
                            //         // Extract Advisory Title
                            //         const advisoryTitle = $("h1").first().text().trim();
                        
                            //         // Extract Mitigation Section
                            //         const mitigationHeading = $("h2:contains('Mitigation')");
                            //         let workarounds = '';
                            //         // if (mitigationHeading.length > 0) {
                            //             workarounds = mitigationHeading.nextUntil("h2").text().trim();

                            //         // }
                        
                            //         return { advisoryTitle, workarounds };
                            //     } catch (error) {
                            //         console.error('Error fetching advisory details:', error);
                            //         return { advisoryTitle: null, workarounds: null };
                            //     }
                            // }
                        
                            (async () => {
                                // const { advisoryTitle, workarounds } = await fetchAdvisoryDetails(advisoryUrl);
                        
                                // Use the fetched data after ensuring it's available
                                setTimeout(() => {
                                    let saveData = {
                                        vendorName: Product.oemName,
                                        productName: asset.product,
                                        month: month,
                                        year: year,
                                        date: cveData.cve.published,
                                        fix: "N",
                                        seviarity: severity,
                                        cveId: cveData.cve.id,
                                        cveDetails: cveData,
                                        version: Product.version,
                                        partNo: asset.partNo,
                                        serialNo: asset.serialNo,
                                        osType: asset.osType,
                                        type: assets.type,
                                        project: asset.project,
                                        advisoryTitle: advisoryTitle || 'No title found',
                                        cvssScore: priorityMetric.cvssData.baseScore,
                                        fixedRelease: fixedRelease,
                                        advisoryUrl: advisoryUrl,
                                        workarounds: workarounds || 'No workarounds found'
                                    };
                        
                                    vendorProductCveModel.create(saveData);
                                }, 1000);
                            })();
                        }
                        
                        if(asset.vendor != "F5"){
                         
                          let saveData = {
                            vendorName: Product.oemName,
                            productName: asset.product,
                            month: month,
                            year: year,
                            date: cveData.cve.published,
                            fix: "N",
                            seviarity: severity,
                            cveId: cveData.cve.id,
                            cveDetails: cveData,
                            version: Product.version,
                            partNo: asset.partNo,
                            serialNo: asset.serialNo,
                            osType: asset.osType,
                            type: assets.type,
                            project: asset.project,
                            advisoryTitle: advisoryTitle,
                            cvssScore: priorityMetric.cvssData.baseScore,
                            fixedRelease: fixedRelease,
                            advisoryUrl: advisoryUrl,
                            workarounds: workarounds,
                          };
                          vendorProductCveModel.create(saveData);
                        }
                          //}
                        } catch (error) {
                          console.error(
                            "Error occurred during scraping:",
                            error
                          );
                        }
                      };

                      // Run the scraper
                      await scrapeCiscoPage();
                    } else {
                      let dateVal = cveData.cve.published;
                      let monthYear = dateVal.split("-", 2);
                      let month = monthYear[1];
                      let year = monthYear[0];
                      const scrapeCiscoPage = async () => {
                        let fixedRelease = "";
                        let advisoryTitle = "";
                        let advisoryUrl = "";
                        let workarounds = "";
                        try {
                          if (asset.vendor == "Solarwinds") {
                            // Fetch HTML content from the advisory URL
                            advisoryUrl = `https://www.solarwinds.com/trust-center/security-advisories/${cveData?.cve?.id}`;
                            const html = await rp(advisoryUrl);
                            if (html) {
                              const $ = cheerio.load(html);
                              advisoryTitle = $("h1").text().trim();
                              const fixedReleaseArray = $("h3")
                                .filter((i, el) =>
                                  $(el)
                                    .text()
                                    .toLowerCase()
                                    .includes("fixed software release")
                                )
                                .next("ul") // Navigate to the sibling <ul> element
                                .find("li") // Find all <li> elements under the <ul>
                                .map((i, el) => $(el).text().trim()) // Extract text content for each list item
                                .get(); // Convert to an array

                              // Convert the array to a string (comma-separated)
                              fixedRelease = fixedReleaseArray.join(", ");
                            }

                          }
                          if (asset.vendor == "Microsoft") {
                            advisoryUrl = `https://msrc.microsoft.com/update-guide/vulnerability/${cveData?.cve?.id}`;
                        
                            try {
                                const html = await rp(advisoryUrl);
                                if (html) {
                                    const $ = cheerio.load(html);
                                    // Select the `h1` with the specific class
                                    advisoryTitle = $("h1.ms-fontWeight-semibold.css-199").text().trim();
                                }
                            } catch (error) {
                                console.error('Error fetching or parsing advisory URL:', error);
                            }
                        }
                          if (asset.vendor == "Fortinet") {
                            advisoryUrl = cveData?.cve?.references[0].url;
                            const html = await rp(advisoryUrl);
                            if (html) {
                              const $ = cheerio.load(html);
                              advisoryTitle = $("h1").text().trim();
                          
                              fixedRelease = $("table")
                              .find("tbody tr") // Locate all table rows in the body
                              .first() // Get the first row
                              .find("td") // Locate all table cells in the row
                              .last() // Get the last cell (Solution column)
                              .text() // Extract its text content
                              .trim();
                        
                        
                            }

                          }
                          if (asset.vendor == "F5") {
                            const puppeteer = require('puppeteer');
                            const cheerio = require('cheerio');
                        
                            const matchingUrls = cveData?.cve?.references.filter(ref => ref.url.includes('my.f5.com'));
                            const advisoryUrl = matchingUrls?.[0]?.url || cveData?.cve?.references[0]?.url;
                        
                            // async function fetchAdvisoryDetails(url) {
                            //     try {
                            //         const browser = await puppeteer.launch({ headless: true });
                            //         const page = await browser.newPage();
                            //         await page.goto(url, { waitUntil: 'networkidle0' });
                            //         await page.waitForSelector('h1', { timeout: 10000 });
                            //         const html = await page.content();
                            //         if (!html) {
                            //           console.log('Failed to fetch page content.');
                            //           return;
                            //       }
                          
                            //         await browser.close();
                        
                            //         const $ = cheerio.load(html);
                        
                            //         // Extract Advisory Title
                            //         const advisoryTitle = $("h1").first().text().trim();
                        
                            //         // Extract Mitigation Section
                            //         const mitigationHeading = $("h2:contains('Mitigation')");
                            //         console.log('mitigation',mitigationHeading)
                            //         let workarounds = '';
                            //         // if (mitigationHeading.length > 0) {
                            //             workarounds = mitigationHeading.nextUntil("h2").text().trim();
                            //             console.log('workarounds',workarounds)

                            //         // }
                        
                            //         return { advisoryTitle, workarounds };
                            //     } catch (error) {
                            //         console.error('Error fetching advisory details:', error);
                            //         return { advisoryTitle: null, workarounds: null };
                            //     }
                            // }
                        
                            (async () => {
                                // const { advisoryTitle, workarounds } = await fetchAdvisoryDetails(advisoryUrl);
                        
                                // Use the fetched data after ensuring it's available
                                setTimeout(() => {
                                    let saveData = {
                                        vendorName: Product.oemName,
                                        productName: asset.product,
                                        month: month,
                                        year: year,
                                        date: cveData.cve.published,
                                        fix: "N",
                                        seviarity: severity,
                                        cveId: cveData.cve.id,
                                        cveDetails: cveData,
                                        version: Product.version,
                                        partNo: asset.partNo,
                                        serialNo: asset.serialNo,
                                        osType: asset.osType,
                                        type: assets.type,
                                        project: asset.project,
                                        advisoryTitle: advisoryTitle || 'No title found',
                                        cvssScore: priorityMetric.cvssData.baseScore,
                                        fixedRelease: fixedRelease,
                                        advisoryUrl: advisoryUrl,
                                        workarounds: workarounds || 'No workarounds found'
                                    };
                        
                                    vendorProductCveModel.create(saveData);
                                }, 1000);
                            })();
                        }
                        
                        if(asset.vendor != "F5"){
                          let saveData = {
                            vendorName: Product.oemName,
                            productName: asset.product,
                            month: month,
                            year: year,
                            date: cveData.cve.published,
                            fix: "N",
                            seviarity: severity,
                            cveId: cveData.cve.id,
                            cveDetails: cveData,
                            version: Product.version,
                            partNo: asset.partNo,
                            serialNo: asset.serialNo,
                            osType: asset.osType,
                            project: asset.project,
                            type: asset.type,
                          };
                          vendorProductCveModel.create(saveData);
                        }
                          //}
                        } catch (error) {
                          console.error(
                            "Error occurred during scraping:",
                            error
                          );
                        }
                      };

                      // Run the scraper
                      await scrapeCiscoPage();

                      //}
                    }
                  }
                });
              }
            })
            .catch((error) => {
              runAssetProductCveMappingSchedulerLogger.error(
                `Error in accessing the API ${error}`
              );
              console.log(error);
            });
        }
      }

      if (count == assetsCount) {
        runAssetProductCveMappingSchedulerLogger.info(
          "Scheduler run successfully & stored cves"
        );
        response.send("scheduler run successfully");
      }
    }
  } catch (error) {
    runAssetProductCveMappingSchedulerLogger.error(error);
    console.log("err", error);
  }
};

//     const { fromDate, toDate } = request.body;

//     const buildDateRangeQuery = () => {
//       const formatDate = (date) => date.toISOString();

//       if (!fromDate && !toDate) {
//         const currentDate = new Date();
//         const lastMonthDate = new Date();
//         lastMonthDate.setMonth(currentDate.getMonth() - 1);

//         return {
//           date: {
//             $gte: lastMonthDate,
//             $lte: currentDate,
//           },
//         };
//       } else {
//         return {
//           date: {
//             $gte: fromDate ? formatDate(new Date(fromDate)) : undefined,
//             $lte: toDate ? formatDate(new Date(toDate)) : undefined,
//           },
//         };
//       }
//     };

//     try {
//       const dateRangeQuery = buildDateRangeQuery();
//       const query = {
//         ...dateRangeQuery,
//       };

//       // Fetch records from the database
//       const filteredCves = await vendorProductCveModel.find(query);
//       response.status(200).json(filteredCves);
//     } catch (error) {
//       console.error('Error fetching filtered CVEs', error);
//       response.status(500).json({ error: 'Error fetching filtered CVEs' });
//     }
//   };
export const getVenderProductCves = async (request, response) => {
  const { fromDate, toDate } = request.body;

  const buildDateRangeQuery = () => {
    const formatDate = (date) => date.toISOString();

    if (!fromDate && !toDate) {
      const currentDate = new Date();
      const lastMonthDate = new Date();
      lastMonthDate.setMonth(currentDate.getMonth() - 1);

      return {
        date: {
          $gte: lastMonthDate,
          $lte: currentDate,
        },
      };
    } else {
      return {
        date: {
          $gte: fromDate ? formatDate(new Date(fromDate)) : undefined,
          $lte: toDate ? formatDate(new Date(toDate)) : undefined,
        },
      };
    }
  };

  try {
    const dateRangeQuery = buildDateRangeQuery();

    const matchQuery = {
      ...dateRangeQuery,
      $or: [
        { "cveDetails.cve.metrics.cvssMetricV30": { $exists: true, $ne: [] } },
        { "cveDetails.cve.metrics.cvssMetricV31": { $exists: true, $ne: [] } },
      ],
    };

    const aggregationPipeline = [
      { $match: matchQuery },
      {
        $group: {
          _id: "$seviarity",
          count: { $sum: 1 },
        },
      },
    ];

    const seviarityCounts = await vendorProductCveModel.aggregate(
      aggregationPipeline
    );

    const result = {
      criticalCount:
        seviarityCounts.find((item) => item._id === "CRITICAL")?.count || 0,
      highCount:
        seviarityCounts.find((item) => item._id === "HIGH")?.count || 0,
      mediumCount:
        seviarityCounts.find((item) => item._id === "MEDIUM")?.count || 0,
      lowCount: seviarityCounts.find((item) => item._id === "LOW")?.count || 0,
      totalCount: seviarityCounts.reduce((acc, item) => acc + item.count, 0),
    };

    response.status(200).json(result);
  } catch (error) {
    console.error("Error fetching and counting filtered CVEs", error);
    response
      .status(500)
      .json({ error: "Error fetching and counting filtered CVEs" });
  }
};

export const getVenderProductForGraphs = async (request, response) => {
  const { seviarity, fromDate, toDate } = request.body;
  const buildDateRangeQuery = () => {
    const formatDate = (date) => date.toISOString();

    if (!fromDate && !toDate) {
      const currentDate = new Date();
      const lastMonthDate = new Date();
      lastMonthDate.setMonth(currentDate.getMonth() - 1);

      return {
        date: {
          $gte: lastMonthDate,
          $lte: currentDate,
        },
      };
    } else {
      return {
        date: {
          $gte: fromDate ? formatDate(new Date(fromDate)) : undefined,
          $lte: toDate ? formatDate(new Date(toDate)) : undefined,
        },
      };
    }
  };

  try {
    const dateRangeQuery = buildDateRangeQuery();

    const matchQuery = {
      ...dateRangeQuery,
      $or: [
        { "cveDetails.cve.metrics.cvssMetricV30": { $exists: true, $ne: [] } },
        { "cveDetails.cve.metrics.cvssMetricV31": { $exists: true, $ne: [] } },
      ],
    };

    if (seviarity) {
      matchQuery.seviarity = seviarity.toUpperCase(); // Ensure case consistency
    }
    const result = await vendorProductCveModel.find(matchQuery);

    response.status(200).json(result);
  } catch (error) {
    console.error("Error fetching and counting filtered CVEs", error);
    response
      .status(500)
      .json({ error: "Error fetching and counting filtered CVEs" });
  }
};

async function cveEligibleCheck(
  vulnerability,
  cpeName,
  cpeCriteria,
  Product,
  partNo,
  asset
) {
  // console.log('1')
  let distinctCveIds;

  processVulnerability(vulnerability, cpeName, cpeCriteria).then((cveIds) => {
    
    distinctCveIds = [...new Set(cveIds)];
    // }
    // else{

    //     distinctCveIds = [...new Set(response.vulnerabilities)];
    // }
    //  console.log(distinctCveIds, 'distinctCveIds', cveIds)
    if (distinctCveIds != undefined && distinctCveIds.length > 0) {
      distinctCveIds.forEach(async (cveData) => {
        let cve = await vendorProductCveModel.findOne({
          cveId: cveData.cve.id,
          vendorName: Product.oemName,
          productName: Product.title,
          version: Product.version,
          osType: asset.osType,
        });
        if (cve) {
          console.log("cveId already exists");
        } else {
          const metrcis = cveData.cve.metrics;
          let severity = "";

          let cveDataCopy = {
            ...cveData.cveDetails,
          };

          if (Object.keys(metrcis).length > 0) {
            const filteredMetrics = [];
            Object.keys(metrcis).forEach((key) => {
              const sortedMetrics = metrcis[key].sort((a, b) =>
                a.cvssData.baseScore < b.cvssData.baseScore
                  ? 1
                  : a.cvssData.baseScore > b.cvssData.baseScore
                  ? -1
                  : 0
              );
              filteredMetrics.push(sortedMetrics[0]);
            });

            const priorityMetric = filteredMetrics.sort((a, b) =>
              a.cvssData.baseScore < b.cvssData.baseScore
                ? 1
                : a.cvssData.baseScore > b.cvssData.baseScore
                ? -1
                : 0
            )[0];

            cveDataCopy = {
              ...cveDataCopy,
              metrics: {
                [Object.keys(metrcis)[0]]: [
                  {
                    ...priorityMetric,
                  },
                ],
              },
            };
            severity =
              priorityMetric.cvssData.baseSeverity ??
              priorityMetric.baseSeverity;

            let dateVal = cveData.cve.published;
            let monthYear = dateVal.split("-", 2);
            let month = monthYear[1];
            let year = monthYear[0];
            let fixedRelease = "";
            let advisoryTitle = "";
            let advisoryUrl = "";
            let workarounds = "";
            let vulnerableComponent = "";
            let vulnerableFeature = "";

            let saveData = {
              vendorName: Product.oemName,
              productName: asset.product,
              month: month,
              year: year,
              date: cveData.cve.published,
              fix: "N",
              seviarity: severity,
              cveId: cveData.cve.id,
              cveDetails: cveData,
              version: asset.firmwareVersion,
              partNo: asset.partNo,
              serialNo: asset.serialNo,
              osType: asset.osType,
              project: asset.project,
              type: asset.type,
              advisoryTitle: advisoryTitle,
              cvssScore: priorityMetric.cvssData.baseScore,
              fixedRelease: fixedRelease,
              advisoryUrl: advisoryUrl,
              workarounds: workarounds,
              vulnerableComponent: vulnerableComponent,
              vulnerableFeature: vulnerableFeature,
            };
            vendorProductCveModel.create(saveData);


            const scrapeCiscoPage = async () => {
              try {
                let fixedRelease = "";
                let advisoryTitle = "";
                let advisoryUrl = "";
                let workarounds = "";
                let vulnerableComponent = "";
                let vulnerableFeature = "";

                // if (asset.vendor == "Cisco") {
                //   advisoryUrl = cveData?.cve?.references[0].url;
                //   const html = await rp(advisoryUrl);
                //   if (html) {
                //     const $ = cheerio.load(html);
                //     advisoryTitle = $("h1").text().trim();

                //     const workaroundsHeading = $("h2").filter((i, el) =>
                //       $(el).text().toLowerCase().includes("workarounds")
                //     );
                //     workarounds = workaroundsHeading
                //       .nextUntil("h2")
                //       .text()
                //       .trim(); // Extract content until next <h2> tag

                //     const affectedProductsHeading = $("h2").filter((i, el) =>
                //       $(el).text().toLowerCase().includes("affected products")
                //     );

                //     vulnerableComponent =
                //       affectedProductsHeading
                //         .nextUntil("h3") 
                //         .text() 
                //         .match(/The web UI feature is enabled/i)?.[0] 
                //         .trim() || "";

                //     const affectedDetermineHeading = $("h3").filter((i, el) =>
                //       $(el)
                //         .text()
                //         .toLowerCase()
                //         .includes("determine the http server configuration")
                //     );

                //     vulnerableFeature = affectedDetermineHeading
                //     .nextUntil("h1") 
                //     .text()
                //     .trim();
                //   }
                // }
               
                //}
              } catch (error) {
                console.error("Error occurred during scraping:", error);
              }
            };

            // await scrapeCiscoPage();
          } else {
            let dateVal = cveData.cve.published;
            let monthYear = dateVal.split("-", 2);
            let month = monthYear[1];
            let year = monthYear[0];
            let fixedRelease = "";
                let advisoryTitle = "";
                let advisoryUrl = "";
                let workarounds = "";
                let vulnerableComponent = "";
                let vulnerableFeature = "";

               
                let saveData = {
                  vendorName: Product.oemName,
                  productName: asset.product,
                  month: month,
                  year: year,
                  date: cveData.cve.published,
                  fix: "N",
                  seviarity: severity,
                  cveId: cveData.cve.id,
                  cveDetails: cveData,
                  version: firmwareVersion,
                  partNo: asset.partNo,
                  serialNo: asset.serialNo,
                  osType: asset.osType,
                  project: asset.project,
                  type: asset.type,
                  advisoryTitle: advisoryTitle,
                  cvssScore: priorityMetric.cvssData.baseScore,
                  fixedRelease: fixedRelease,
                  advisoryUrl: advisoryUrl,
                  workarounds: workarounds,
                  vulnerableComponent: vulnerableComponent,
                  vulnerableFeature: vulnerableFeature,
                };
                vendorProductCveModel.create(saveData);
            // const scrapeCiscoPage = async () => {
            //   try {
                

            //     // if (asset.vendor == "Cisco") {
            //     //   advisoryUrl = cveData?.cve?.references[0].url;
            //     //   const html = await rp(advisoryUrl);
            //     //   if (html) {
            //     //     const $ = cheerio.load(html);
            //     //     advisoryTitle = $("h1").text().trim();

            //     //     const workaroundsHeading = $("h2").filter((i, el) =>
            //     //       $(el).text().toLowerCase().includes("workarounds")
            //     //     );
            //     //     workarounds = workaroundsHeading
            //     //       .nextUntil("h2")
            //     //       .text()
            //     //       .trim(); // Extract content until next <h2> tag

            //     //     const affectedProductsHeading = $("h2").filter((i, el) =>
            //     //       $(el).text().toLowerCase().includes("affected products")
            //     //     );

            //     //     vulnerableComponent =
            //     //       affectedProductsHeading
            //     //         .nextUntil("h3") 
            //     //         .text() 
            //     //         .match(/The web UI feature is enabled/i)?.[0] 
            //     //         .trim() || "";

            //     //     const affectedDetermineHeading = $("h3").filter((i, el) =>
            //     //       $(el)
            //     //         .text()
            //     //         .toLowerCase()
            //     //         .includes("determine the http server configuration")
            //     //     );

            //     //     vulnerableFeature = affectedDetermineHeading
            //     //       .nextUntil("h1") // Select all sibling elements until the next <h1>
            //     //       .text() // Extract text content
            //     //       .trim();
            //     //   }
            //     // }
            //     // let saveData = {
            //     //   vendorName: Product.oemName,
            //     //   productName: partNo.toLowerCase(),
            //     //   month: month,
            //     //   year: year,
            //     //   date: cveData.cve.published,
            //     //   fix: "N",
            //     //   seviarity: severity,
            //     //   cveId: cveData.cve.id,
            //     //   cveDetails: cveData,
            //     //   version: firmwareVersion,
            //     //   partNo: asset.partNo,
            //     //   serialNo: asset.serialNo,
            //     //   osType: asset.osType,
            //     //   project: asset.project,
            //     //   type: asset.type,
            //     //   advisoryTitle: advisoryTitle,
            //     //   cvssScore: priorityMetric.cvssData.baseScore,
            //     //   fixedRelease: fixedRelease,
            //     //   advisoryUrl: advisoryUrl,
            //     //   workarounds: workarounds,
            //     //   vulnerableComponent: vulnerableComponent,
            //     //   vulnerableFeature: vulnerableFeature,
            //     // };
            //     // vendorProductCveModel.create(saveData);
            //     //}
            //   } catch (error) {
            //     console.error("Error occurred during scraping:", error);
            //   }
            // };

            // Run the scraper
            // await scrapeCiscoPage();

            //}
          }
        }
      });
    }
  });
}

async function processVulnerability(vulnerability, cpeName, cpeCriteria) {
  let parentNode, childrenNode, childrenOrNode;
  let matchedCveIds = [];
  let matchingCriteriaCount = 0;

  vulnerability.cve.configurations.forEach((configuration) => {
    let isPush = false;
    let startIncludingEndIncludingCheck = false;
    let startIncludingEndExcludingCheck = false;

    let endExcludingCheck = false;
    let endIncludingCheck = false;
    let versionStartIncluding = false;

    let parentNodes = [],
      childrenNodes = [],
      childrenOrNodes = [];

    if (configuration.nodes && configuration.operator === "AND") {
      return processAndCpeMatches(
        configuration.nodes,
        cpeName,
        parentNodes,
        childrenNodes,
        cpeCriteria,
        isPush,
        startIncludingEndIncludingCheck,
        startIncludingEndExcludingCheck,
        endExcludingCheck,
        endIncludingCheck,
        matchingCriteriaCount,
        matchedCveIds,
        vulnerability,
        versionStartIncluding
      );
    } else if (configuration.nodes && configuration.operator !== "AND") {
      return processOrCpeMatches(
        configuration.nodes,
        cpeName,
        childrenOrNodes,
        matchingCriteriaCount,
        matchedCveIds,
        vulnerability,
        isPush,
        startIncludingEndIncludingCheck,
        startIncludingEndExcludingCheck,
        endExcludingCheck,
        endIncludingCheck,
        versionStartIncluding
      );
    }
  });
// matchedCveIds.push(vulnerability)
  return matchedCveIds;
}

async function processOrCpeMatches(
  nodes,
  cpeName,
  childrenOrNodes,
  matchingCriteriaCount,
  matchedCveIds,
  vulnerability,
  isPush,
  startIncludingEndIncludingCheck,
  startIncludingEndExcludingCheck,
  endExcludingCheck,
  endIncludingCheck,
  versionStartIncluding
) {
  const cpeVersionSegments = cpeName.split(":");
  //  const cpeLastNumber = cpeVersionSegments[5]

  // const regex = /[^\w\s.]/;

  // let cpeLastNumber = cpeVersionSegments[5];
  // let uniqueLastNumber;
  // if (regex.test(cpeLastNumber)) {
  //     const versionNumberWithSpecialChars = cpeVersionSegments[5];
  //     const match = versionNumberWithSpecialChars.match(/([\d.]+)/);
  //     uniqueLastNumber = match ? match[0] : undefined;
  // } else {
  //     uniqueLastNumber = cpeLastNumber;
  // }

  const regex = /[^\w\s.]/;

  let cpeLastNumber = cpeVersionSegments[5];
  let uniqueLastNumber;
  if (regex.test(cpeLastNumber)) {
    let versionNumberWithSpecialChars = cpeVersionSegments[5];

    if (versionNumberWithSpecialChars.includes("%5C")) {
      versionNumberWithSpecialChars = versionNumberWithSpecialChars.replace(
        /%5C/g,
        ""
      );
    }

    const match = versionNumberWithSpecialChars.match(/([\d.]+)\((\d+)\)/);
    if (match) {
      uniqueLastNumber = match[1] + "." + match[2];
    } else {
      uniqueLastNumber = undefined;
    }
  } else {
    uniqueLastNumber = cpeLastNumber;
  }

  const cpeNameSplit = cpeVersionSegments.slice(0, 6).join(":");

  nodes.map(async (node) => {
    node.cpeMatch.map(async (cpeMatch) => {
      if (cpeMatch.vulnerable) {
        const cpeVendorOsType = cpeName.split(":");
        const cveVendorOsType = cpeMatch.criteria.split(":");


        if (
          cveVendorOsType[3] == cpeVendorOsType[3] &&
          cveVendorOsType[4] == cpeVendorOsType[4] 
        ) {
          childrenOrNodes.push({ cpeMatch });
        }
      }
    });
  });

  // await Promise.all(nodes.map(async (node) => {
  //     await Promise.all(node.cpeMatch.map(async (cpeMatch) => {

  //         if(cpeMatch.vulnerable){

  //                     const cpeVendorOsType = cpeName.split(':');
  //                     const cveVendorOsType = cpeMatch.criteria.split(':');

  //                     if (cveVendorOsType[3] == cpeVendorOsType[3] && cveVendorOsType[4] == cpeVendorOsType[4]) {
  //                         childrenOrNodes.push({cpeMatch});
  //                     }
  //                 }

  //     }));
  // }));

  childrenOrNodes.some((childrenOrNode) => {
    let startIncludingEndIncludingCheck = false;
    let startIncludingEndExcludingCheck = false;

    let endExcludingCheck = false;
    let endIncludingCheck = false;
    let versionStartIncluding = false;

    const cpeSegments = childrenOrNode.cpeMatch.criteria.split(":");

    let cpeMatchFirstFive = cpeSegments.slice(0, 6).join(":");

    if (cpeMatchFirstFive.includes("\\")) {
      cpeMatchFirstFive = cpeMatchFirstFive.replace(/\\/g, "%5C");
    }

    if (
      childrenOrNode.cpeMatch.versionEndExcluding &&
      childrenOrNode.cpeMatch.versionStartIncluding
    ) {
      if (childrenOrNode.cpeMatch.versionStartIncluding.includes("\\")) {
        childrenOrNode.cpeMatch.versionStartIncluding =
          childrenOrNode.cpeMatch.versionStartIncluding.replace(/\\/g, "");
      }

      if (childrenOrNode.cpeMatch.versionEndExcluding.includes("\\")) {
        childrenOrNode.cpeMatch.versionEndExcluding =
          childrenOrNode.cpeMatch.versionEndExcluding.replace(/\\/g, "");
      }
      startIncludingEndExcludingCheck = true;
    } else if (
      !startIncludingEndExcludingCheck &&
      childrenOrNode.cpeMatch.versionEndIncluding &&
      childrenOrNode.cpeMatch.versionStartIncluding
    ) {
      if (childrenOrNode.cpeMatch.versionEndIncluding.includes("\\")) {
        childrenOrNode.cpeMatch.versionEndIncluding =
          childrenOrNode.cpeMatch.versionEndIncluding.replace(/\\/g, "");
      }

      if (childrenOrNode.cpeMatch.versionStartIncluding.includes("\\")) {
        childrenOrNode.cpeMatch.versionStartIncluding =
          childrenOrNode.cpeMatch.versionStartIncluding.replace(/\\/g, "");
      }
      startIncludingEndIncludingCheck = true;
    } else if (
      !startIncludingEndExcludingCheck &&
      !startIncludingEndIncludingCheck &&
      childrenOrNode.cpeMatch.versionEndExcluding
    ) {
      if (childrenOrNode.cpeMatch.versionEndExcluding.includes("\\")) {
        childrenOrNode.cpeMatch.versionEndExcluding =
          childrenOrNode.cpeMatch.versionEndExcluding.replace(/\\/g, "");
      }
      endExcludingCheck = true;
    } else if (
      !startIncludingEndExcludingCheck &&
      !startIncludingEndIncludingCheck &&
      !endExcludingCheck &&
      childrenOrNode.cpeMatch.versionEndIncluding
    ) {
      if (childrenOrNode.cpeMatch.versionEndIncluding.includes("\\")) {
        childrenOrNode.cpeMatch.versionEndIncluding =
          childrenOrNode.cpeMatch.versionEndIncluding.replace(/\\/g, "");
      }
      endIncludingCheck = true;
    } else if (
      !startIncludingEndExcludingCheck &&
      !startIncludingEndIncludingCheck &&
      !endExcludingCheck &&
      !endIncludingCheck &&
      childrenOrNode.cpeMatch.versionStartIncluding
    ) {
      if (childrenOrNode.cpeMatch.versionStartIncluding.includes("\\")) {
        childrenOrNode.cpeMatch.versionStartIncluding =
          childrenOrNode.cpeMatch.versionStartIncluding.replace(/\\/g, "");
      }
      versionStartIncluding = true;
    }

    //     if(!startIncludingEndExcludingCheck && !endIncludingCheck && !endExcludingCheck &&
    //         !startIncludingEndIncludingCheck ){
    //             isPush = true;
    //         }
    //    else

    if (cpeNameSplit === cpeMatchFirstFive) {
      isPush = true;
    } else if (
      versionStartIncluding &&
      isVersionGreaterThanOrEqualTo(
        uniqueLastNumber,
        childrenOrNode.cpeMatch.versionStartIncluding
      )
    ) {
      isPush = true;
    } else if (
      !versionStartIncluding &&
      startIncludingEndIncludingCheck &&
      isVersionGreaterThanOrEqualTo(
        uniqueLastNumber,
        childrenOrNode.cpeMatch.versionStartIncluding
      ) &&
      isVersionLessThanOrEqualTo(
        uniqueLastNumber,
        childrenOrNode.cpeMatch.versionEndIncluding
      )
    ) {
      isPush = true;
    } else if (
      !versionStartIncluding &&
      !startIncludingEndIncludingCheck &&
      startIncludingEndExcludingCheck &&
      isVersionGreaterThanOrEqualTo(
        uniqueLastNumber,
        childrenOrNode.cpeMatch.versionStartIncluding
      ) &&
      isVersionLessThanOrEqualTo(
        uniqueLastNumber,
        childrenOrNode.cpeMatch.versionEndExcluding
      )
    ) {
      isPush = true;
    } else if (
      !versionStartIncluding &&
      !startIncludingEndIncludingCheck &&
      !startIncludingEndExcludingCheck &&
      !endExcludingCheck &&
      endIncludingCheck &&
      isVersionLessThanOrEqualTo(
        uniqueLastNumber,
        childrenOrNode.cpeMatch.versionEndIncluding
      )
    ) {
      isPush = true;
    } else if (
      endExcludingCheck &&
      isVersionLessThan(
        uniqueLastNumber,
        childrenOrNode.cpeMatch.versionEndExcluding
      )
    ) {
      isPush = true;
    }
    // return vulnerability;

    if (isPush) {
      matchingCriteriaCount++;
      matchedCveIds.push(vulnerability);
      return matchedCveIds;
    }
  });
}

async function processAndCpeMatches(
  nodes,
  cpeName,
  parentNodes,
  childrenNodes,
  cpeCriteria,
  isPush,
  startIncludingEndIncludingCheck,
  startIncludingEndExcludingCheck,
  endExcludingCheck,
  endIncludingCheck,
  matchingCriteriaCount,
  matchedCveIds,
  vulnerability,
  versionStartIncluding
) {
  nodes.map(async (node) => {
    node.cpeMatch.map(async (cpeMatch) => {
      if (cpeMatch.vulnerable) {
        const cpeVendorOsType = cpeName.split(":");
        const cveVendorOsType = cpeMatch.criteria.split(":");

        if (
          cveVendorOsType[3] == cpeVendorOsType[3] &&
          cveVendorOsType[4] == cpeVendorOsType[4]
        ) {
          parentNodes.push({ cpeMatch });
        }
      } else {
        childrenNodes.push({ cpeMatch });
      }
    });
  });

  // Now that parentNodes is populated, iterate over it
  parentNodes.some((parentNode) => {
    let isChildNodeExist = false;
    let startIncludingEndIncludingCheck = false;
    let startIncludingEndExcludingCheck = false;

    let endExcludingCheck = false;
    let endIncludingCheck = false;
    let versionStartIncluding = false;

    if (
      parentNode.cpeMatch.versionEndExcluding &&
      parentNode.cpeMatch.versionStartIncluding
    ) {
      if (parentNode.cpeMatch.versionStartIncluding.includes("\\")) {
        parentNode.cpeMatch.versionStartIncluding =
          parentNode.cpeMatch.versionStartIncluding.replace(/\\/g, "");
      }

      if (parentNode.cpeMatch.versionEndExcluding.includes("\\")) {
        parentNode.cpeMatch.versionEndExcluding =
          parentNode.cpeMatch.versionEndExcluding.replace(/\\/g, "");
      }
      startIncludingEndExcludingCheck = true;
    } else if (
      !startIncludingEndExcludingCheck &&
      parentNode.cpeMatch.versionEndIncluding &&
      parentNode.cpeMatch.versionStartIncluding
    ) {
      if (parentNode.cpeMatch.versionEndIncluding.includes("\\")) {
        parentNode.cpeMatch.versionEndIncluding =
          parentNode.cpeMatch.versionEndIncluding.replace(/\\/g, "");
      }

      if (parentNode.cpeMatch.versionStartIncluding.includes("\\")) {
        parentNode.cpeMatch.versionStartIncluding =
          parentNode.cpeMatch.versionStartIncluding.replace(/\\/g, "");
      }
      startIncludingEndIncludingCheck = true;
    } else if (
      !startIncludingEndExcludingCheck &&
      !startIncludingEndIncludingCheck &&
      parentNode.cpeMatch.versionEndExcluding
    ) {
      if (parentNode.cpeMatch.versionEndExcluding.includes("\\")) {
        parentNode.cpeMatch.versionEndExcluding =
          parentNode.cpeMatch.versionEndExcluding.replace(/\\/g, "");
      }
      endExcludingCheck = true;
    } else if (
      !startIncludingEndExcludingCheck &&
      !startIncludingEndIncludingCheck &&
      !endExcludingCheck &&
      parentNode.cpeMatch.versionEndIncluding
    ) {
      if (parentNode.cpeMatch.versionEndIncluding.includes("\\")) {
        parentNode.cpeMatch.versionEndIncluding =
          parentNode.cpeMatch.versionEndIncluding.replace(/\\/g, "");
      }
      endIncludingCheck = true;
    } else if (
      !startIncludingEndExcludingCheck &&
      !startIncludingEndIncludingCheck &&
      !endExcludingCheck &&
      !endIncludingCheck &&
      parentNode.cpeMatch.versionStartIncluding
    ) {
      if (parentNode.cpeMatch.versionStartIncluding.includes("\\")) {
        parentNode.cpeMatch.versionStartIncluding =
          parentNode.cpeMatch.versionStartIncluding.replace(/\\/g, "");
      }
      versionStartIncluding = true;
    }

    const cpeVendorOsType = cpeName.split(":");
    const cveVendorOsType = parentNode.cpeMatch.criteria.split(":");

    const cpeNameSplit = cpeVendorOsType.slice(0, 6).join(":");
    let parentCpeMatchFirstFive = cveVendorOsType.slice(0, 6).join(":");
    const segments = parentCpeMatchFirstFive.split(":");

    //  const regex = /[^\w\s.]/;

    //     let cpeLastNumber = cpeVendorOsType[5];
    //     let uniqueLastNumber;
    //     if (regex.test(cpeLastNumber)) {
    //         const versionNumberWithSpecialChars = cpeVendorOsType[5];
    //         const match = versionNumberWithSpecialChars.match(/([\d.]+)/);
    //         uniqueLastNumber = match ? match[0] : undefined;
    //     } else {
    //         uniqueLastNumber = cpeLastNumber;
    //     }

    const regex = /[^\w\s.]/;

    let cpeLastNumber = cpeVendorOsType[5];
    let uniqueLastNumber;
    if (regex.test(cpeLastNumber)) {
      let versionNumberWithSpecialChars = cpeVendorOsType[5];

      if (versionNumberWithSpecialChars.includes("%5C")) {
        versionNumberWithSpecialChars = versionNumberWithSpecialChars.replace(
          /%5C/g,
          ""
        );
      }

      const match = versionNumberWithSpecialChars.match(/([\d.]+)\((\d+)\)/);
      if (match) {
        uniqueLastNumber = match[1] + "." + match[2];
      } else {
        uniqueLastNumber = undefined;
      }
    } else {
      uniqueLastNumber = cpeLastNumber;
    }

    if (parentCpeMatchFirstFive.includes("\\")) {
      parentCpeMatchFirstFive = parentCpeMatchFirstFive.replace(/\\/g, "%5C");
    }

    if (
      !startIncludingEndExcludingCheck &&
      !endIncludingCheck &&
      !endExcludingCheck &&
      !startIncludingEndIncludingCheck &&
      !versionStartIncluding &&
      childrenNodes &&
      childrenNodes.length == 0
    ) {
      matchingCriteriaCount++;
      matchedCveIds.push(vulnerability);
    } else if (cpeNameSplit === parentCpeMatchFirstFive) {
      if (childrenNodes && childrenNodes.length > 0) {
        isChildNodeExist = true;
        childrenNodes.forEach((childNode) => {
          if (childNode.cpeMatch.criteria === cpeCriteria) {
            matchingCriteriaCount++;
            matchedCveIds.push(vulnerability);
          }
          if (
            childNode.cpeMatch.criteria === cpeCriteria &&
            uniqueLastNumber &&
            childNode.cpeMatch.versionStartIncluding &&
            childNode.cpeMatch.versionEndExcluding &&
            isVersionGreaterThanOrEqualTo(
              uniqueLastNumber,
              childNode.cpeMatch.versionStartIncluding
            ) &&
            isVersionLessThan(
              uniqueLastNumber,
              childNode.cpeMatch.versionEndExcluding
            )
          ) {
            matchingCriteriaCount++;
            matchedCveIds.push(vulnerability);
          }
          if (
            childNode.cpeMatch.criteria === cpeCriteria &&
            uniqueLastNumber &&
            uniqueLastNumber <= childNode.cpeMatch.versionEndExcluding
          ) {
            matchingCriteriaCount++;
            matchedCveIds.push(vulnerability);
          }
        });
      }
    } else if (
      !startIncludingEndExcludingCheck &&
      !endIncludingCheck &&
      !endExcludingCheck &&
      !startIncludingEndIncludingCheck &&
      !versionStartIncluding &&
      childrenNodes &&
      childrenNodes.length > 0
    ) {
      const parentCpeMatchFirstFiveCHeck = parentCpeMatchFirstFive.split(":");
      if (
        parentCpeMatchFirstFiveCHeck[5] == "-" ||
        parentCpeMatchFirstFiveCHeck[5] == "-"
      ) {
        isChildNodeExist = true;
        childrenNodes.forEach((childCpeMatch) => {
          if (childCpeMatch.cpeMatch.criteria === cpeCriteria) {
            isPush = true;
          }
        });
      }
    } else if (
      versionStartIncluding &&
      isVersionGreaterThanOrEqualTo(
        uniqueLastNumber,
        parentNode.cpeMatch.versionStartIncluding
      )
    ) {
      if (childrenNodes && childrenNodes.length > 0) {
        isChildNodeExist = true;
        childrenNodes.forEach((childCpeMatch) => {
          if (childCpeMatch.cpeMatch.criteria === cpeCriteria) {
            isPush = true;
          }
        });
      } else {
        isPush = true;
      }
    } else if (
      startIncludingEndIncludingCheck &&
      isVersionGreaterThanOrEqualTo(
        uniqueLastNumber,
        parentNode.cpeMatch.versionStartIncluding
      ) &&
      isVersionLessThanOrEqualTo(
        uniqueLastNumber,
        parentNode.cpeMatch.versionEndIncluding
      )
    ) {
      if (childrenNodes && childrenNodes.length > 0) {
        isChildNodeExist = true;
        childrenNodes.forEach((childCpeMatch) => {
          if (childCpeMatch.cpeMatch.criteria === cpeCriteria) {
            isPush = true;
          }
        });
      } else {
        isPush = true;
      }
    } else if (
      !startIncludingEndIncludingCheck &&
      startIncludingEndExcludingCheck &&
      isVersionGreaterThanOrEqualTo(
        uniqueLastNumber,
        parentNode.cpeMatch.versionStartIncluding
      ) &&
      isVersionLessThanOrEqualTo(
        uniqueLastNumber,
        parentNode.cpeMatch.versionEndExcluding
      )
    ) {
      if (childrenNodes && childrenNodes.length > 0) {
        isChildNodeExist = true;
        childrenNodes.forEach((childCpeMatch) => {
          if (childCpeMatch.cpeMatch.criteria === cpeCriteria) {
            isPush = true;
          }
        });
      } else {
        isPush = true;
      }
    } else if (
      !startIncludingEndIncludingCheck &&
      !startIncludingEndExcludingCheck &&
      !endExcludingCheck &&
      endIncludingCheck &&
      isVersionLessThanOrEqualTo(
        uniqueLastNumber,
        parentNode.cpeMatch.versionEndIncluding
      )
    ) {
      if (childrenNodes && childrenNodes.length > 0) {
        isChildNodeExist = true;
        childrenNodes.forEach((childCpeMatch) => {
          if (childCpeMatch.cpeMatch.criteria === cpeCriteria) {
            isPush = true;
          }
        });
      } else {
        isPush = true;
      }
    } else if (
      endExcludingCheck &&
      isVersionLessThan(
        uniqueLastNumber,
        parentNode.cpeMatch.versionEndExcluding
      )
    ) {
      if (childrenNodes && childrenNodes.length > 0) {
        isChildNodeExist = true;
        childrenNodes.forEach((childCpeMatch) => {
          if (childCpeMatch.cpeMatch.criteria === cpeCriteria) {
            isPush = true;
          }
        });
      } else {
        isPush = true;
      }
    }

    // else if ( isChildNodeExist && startIncludingEndIncludingCheck && isVersionGreaterThanOrEqualTo(uniqueLastNumber , parentNode.cpeMatch.versionStartIncluding )
    //             && isVersionLessThanOrEqualTo(  uniqueLastNumber ,parentNode.cpeMatch.versionEndIncluding) ) {

    //     isPush = true;
    // } else if (isChildNodeExist && !startIncludingEndIncludingCheck && startIncludingEndExcludingCheck && isVersionGreaterThanOrEqualTo(uniqueLastNumber , parentNode.cpeMatch.versionStartIncluding)
    //     &&  isVersionLessThanOrEqualTo(  uniqueLastNumber ,parentNode.cpeMatch.versionEndExcluding)  ) {
    //     isPush = true;

    // } else if (isChildNodeExist && !startIncludingEndIncludingCheck && !startIncludingEndExcludingCheck && endExcludingCheck &&
    //     isVersionLessThan(uniqueLastNumber, parentNode.cpeMatch.versionEndExcluding)) {
    //     isPush = true;

    // }

    // else if ( isChildNodeExist && !startIncludingEndIncludingCheck && !startIncludingEndExcludingCheck && !endExcludingCheck &&
    //     endIncludingCheck && isVersionLessThanOrEqualTo(  uniqueLastNumber ,parentNode.cpeMatch.versionEndIncluding) ) {
    //         isPush = true;
    // }

    if (isPush) {
      matchingCriteriaCount++;
      matchedCveIds.push(vulnerability);
    }
  });
}

function isVersionLessThan(version1, version2) {
  version2 = removechars(version2);
  version1 = removechars(version1);

  const v1 = version1.split(".").map(Number);
  const v2 = version2?.split(".").map(Number);

  for (let i = 0; i < Math.max(v1.length, v2?.length); i++) {
    const num1 = v1[i] || 0;
    const num2 = v2[i] || 0;

    if (num1 > num2) {
      return false;
    } else if (num1 < num2) {
      return true;
    }
  }

  return false;
}

function removechars(ver) {
  let version = ver;

  if (version != undefined) {
    if (version.includes("\\")) {
      version = version.replace(/\\/g, "");
    }

    version = version.replace(/[a-zA-Z]/g, "");
    version = version.replace(/\(|\)/g, ".");
  }
  return version;
}

function isVersionGreaterThan(version1, version2) {
  return !isVersionLessThan(version1, version2);
}

function isVersionLessThanOrEqualTo(version1, version2) {
  if (version2 && version2 != undefined && version1 && version1 != undefined) {
    version2 = removechars(version2);
    version1 = removechars(version1);

    const v1 = version1.split(".").map(Number);
    const v2 = version2?.split(".").map(Number);

    for (let i = 0; i < Math.max(v1.length, v2?.length); i++) {
      const num1 = v1[i] || 0;
      const num2 = v2[i] || 0;
      if (num1 > num2) {
        return false;
      } else if (num1 < num2) {
        return true;
      }
    }
    return true;
  }
  return false;
}

function isVersionGreaterThanOrEqualTo(version1, version2) {
  if (version2 && version2 != undefined && version1 && version1 != undefined) {
    version2 = removechars(version2);
    version1 = removechars(version1);

    const v1 = version1.split(".").map(Number);
    const v2 = version2?.split(".").map(Number);

    for (let i = 0; i < Math.max(v1.length, v2?.length); i++) {
      const num1 = v1[i] || 0;
      const num2 = v2[i] || 0;
      if (num1 < num2) {
        return false;
      } else if (num1 > num2) {
        return true;
      }
    }
    return true;
  }
  return false;
}

export default RunAssetProductCveMappingScheduler;
