import InventoryModel from '../model/inventorySchema.js';
import vendorProductCveModel from '../model/vendorProductCveSchema.js';
import axios from "axios";
import OemCpeModel from '../model/oemProductsSchema.js';

export const RunAssetProductCveMappingScheduler = async (request, response) => {
    try {
      const assets = await InventoryModel.find({})
      let assetsCount = assets.length;
        let count = 0;
        for (const asset of assets) {
            count = count + 1;
            console.log('count',count)
            //let prod = asset.product ? asset.product: asset.partNo;
            let partNo = asset.partNo;
            let isOsType = false;
            let result;
            let checkVersion = false;
            let firmVersion;
            if (partNo) {

                let Product;
                let ProductPartNo = await OemCpeModel.findOne({
                    "title": partNo.toLowerCase()
                });


                let oemList = ["Fortinet", "F5", "Solarwinds", "Microsoft"];

                if (!oemList.includes(asset.vendor)) {
                    checkVersion = true;
                }
                if (checkVersion) {

                    isOsType = true;

                    if(asset.osType != null && asset.osType != undefined && asset.osType != ''){
                        Product = await OemCpeModel.findOne({
                            "title": asset.osType.toLowerCase(),
                            "version": asset.firmwareVersion
                        });

                    }
                    

                } else {


                    if (asset.firmwareVersion == null || asset.firmwareVersion == '-') {

                        Product = await OemCpeModel.findOne({
                            "title": partNo.toLowerCase(),
                            "version": '-'
                        });

                    } else {

                        if (!asset.firmwareVersion.includes('.')) {

                            firmVersion = parseFloat(asset.firmwareVersion).toFixed(1);
                        } else {
                            firmVersion = asset.firmwareVersion;
                        }


                        Product = await OemCpeModel.findOne({
                            "title": partNo.toLowerCase(),
                            "version": firmVersion
                        });

                    }
                }

                if (!Product) {

                    isOsType = true;
                    if(asset.osType != null && asset.osType != undefined && asset.osType != ''){
                        Product = await OemCpeModel.findOne({
                            "title": asset.osType.toLowerCase(),
                            "version": firmVersion
                        });
                    }
                }

                if (Product) {
                    //console.log("cq",Product);

                    //   let url = `https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=${Product.cpeName}`;

                    let url;

                    // if (Product.cpeName.includes('\\') || Product.cpeName.includes('(') || Product.cpeName.includes(')')) {
                    // const modifiedCpeName = Product.cpeName.replace(/\\/g, '').replace(/\(|\)/g, '.');

                    if (Product.cpeName.includes('\\')) {
                        const modifiedCpeName = Product.cpeName.replace(/\\/g, '%5C');

                        url = `https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=${modifiedCpeName}`;

                    } else {
                        url = `https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=${Product.cpeName}`;
                    }

                    axios.get(
                            url, {
                                headers: {
                                    'apikey': '2d3a2cf2-1934-4620-bce2-f69b9e5dfb43'
                                }
                            })

                        .then(response => {

                          let cveDetails = response.data;


                            // let details = response.data;
                            // let cveDetails;
                            // for (const cve of details.vulnerabilities) {
                            //     // console.log('cveid',cve.cve.id)
                            //     if (cve.cve.id == "CVE-2024-20267") {
                            //         cveDetails = cve;
                            //         break;
                            //     }
                            // }


                            let finalCves = [];
                            let skipOem = false;
                            let oemList = ["Fortinet", "F5", "Solarwinds", "Microsoft"];
                            if (oemList.includes(asset.vendor)) {
                                skipOem = true;
                            }

                            if (isOsType && !skipOem) {

                                try {

                                    let cpeName2 = Product.cpeName;
                                    let cpeName = cpeName2.split(':')
                                    cpeName = cpeName.slice(0, 6).join(':');
                                    let cpeCriteria;
                                    if (ProductPartNo != null) {
                                        cpeCriteria = ProductPartNo.cpeName;
                                    }

                                    //  const { cpeName, cpeCriteria } = request.body;
                                   // let matchingCriteriaCount = 0;
                                  //  let matchedCveIds = [];
                                    const response = cveDetails;
                                    // if (!response.vulnerabilities) {
                                    //     return res.status(200).json({ count: 0, distinctCveIds: [], message: 'No vulnerabilities found.' });
                                    // }
                                   
                                    // if(ProductPartNo != null){
                           response.vulnerabilities.forEach((vulnerability) => {
                                cveEligibleCheck(vulnerability, cpeName, cpeCriteria,Product,partNo,asset);
                                    //processVulnerability(cveDetails, cpeName, cpeCriteria, matchedCveIds, matchingCriteriaCount);
                            });
                                   
                                    //const totalCount = distinctCveIds.length;

                                    //res.status(200).json({ count: totalCount, distinctCveIds, message: 'Found matching products.' });
                                } catch (error) {
                                    console.log(error);
                                    //res.status(500).json({ error: 'Internal server error' });
                                }




                            } else {


                                cveDetails.vulnerabilities.forEach(async (cveData) => {



                                    let cve = await vendorProductCveModel.findOne({
                                        "cveId": cveData.cve.id,
                                        "vendorName": Product.oemName,
                                        "productName": Product.title,
                                        "version": Product.version,
                                        "project":asset.project
                                    });

                                    if (cve) {

                                        console.log("cveId already exists");
                                    } else {



                                        const metrcis = cveData.cve.metrics;
                                        let severity = "";

                                        let cveDataCopy = {
                                            ...cveData.cveDetails
                                        };

                                        if (Object.keys(metrcis).length > 0) {


                                            const filteredMetrics = [];
                                            Object.keys(metrcis).forEach((key) => {
                                                const sortedMetrics = metrcis[key].sort((a, b) => (a.cvssData.baseScore < b.cvssData.baseScore) ? 1 : a.cvssData.baseScore > b.cvssData.baseScore ? -1 : 0);
                                                filteredMetrics.push(sortedMetrics[0])
                                            })

                                            const priorityMetric = filteredMetrics.sort((a, b) => (a.cvssData.baseScore < b.cvssData.baseScore) ? 1 : a.cvssData.baseScore > b.cvssData.baseScore ? -1 : 0)[0];

                                            cveDataCopy = {
                                                ...cveDataCopy,
                                                metrics: {
                                                    [Object.keys(metrcis)[0]]: [{
                                                        ...priorityMetric
                                                    }]
                                                }
                                            }
                                            severity = priorityMetric.cvssData.baseSeverity ?? priorityMetric.baseSeverity

                                            let dateVal = cveData.cve.published;
                                            let monthYear = dateVal.split("-", 2);
                                            let month = monthYear[1];
                                            let year = monthYear[0];
                                            let saveData = {
                                                "vendorName": Product.oemName,
                                                "productName": Product.title,
                                                "month": month,
                                                "year": year,
                                                date: cveData.cve.published,
                                                "fix": "N",
                                                seviarity: severity,
                                                "cveId": cveData.cve.id,
                                                "cveDetails": cveData,
                                                version: Product.version,
                                                "partNo": asset.partNo,
                                                "serialNo": asset.serialNo,
                                                "osType": asset.osType,
                                                "type":asset.type,
                                                "project":asset.project
                                            };
                                            vendorProductCveModel.create(saveData);
                                            //}
                                        } else {

                                            // let cve = await vendorProductCveModel.findOne({"cveId":cveData.cve.id});

                                            // if(cve){
                                            //     console.log("cveId already exists");
                                            // }else{
                                            let dateVal = cveData.cve.published;
                                            let monthYear = dateVal.split("-", 2);
                                            let month = monthYear[1];
                                            let year = monthYear[0];

                                            let saveData = {
                                                "vendorName": Product.oemName,
                                                "productName": Product.title,
                                                "month": month,
                                                "year": year,
                                                date: cveData.cve.published,
                                                "fix": "N",
                                                seviarity: severity,
                                                "cveId": cveData.cve.id,
                                                "cveDetails": cveData,
                                                version: Product.version,
                                                "partNo": asset.partNo,
                                                "serialNo": asset.serialNo,
                                                "osType": asset.osType,
                                                "project":asset.project,
                                                "type":asset.type

                                            };
                                            vendorProductCveModel.create(saveData);
                                            //}

                                        }
                                    }
                                });
                            }

                        }).catch(error => console.log(error))

                }

            }


            if (count == assetsCount) {

                response.send("scheduler run successfully");
            }
        }


    } catch (error) {
        console.log('err',error)

    }
};

async function cveEligibleCheck(vulnerability, cpeName, cpeCriteria,Product,partNo,asset){

   // console.log('1')
    let distinctCveIds;

    processVulnerability(vulnerability, cpeName, cpeCriteria).then((cveIds) => {

        
         distinctCveIds = [...new Set(cveIds)];
         // }
         // else{
     
         //     distinctCveIds = [...new Set(response.vulnerabilities)];
         // }
       //  console.log(distinctCveIds, 'distinctCveIds', cveIds)
         if (distinctCveIds != undefined && distinctCveIds.length>0) {
             distinctCveIds.forEach(async (cveData) => {
     
                 let cve = await vendorProductCveModel.findOne({
                     "cveId": cveData.cve.id,
                     "vendorName": Product.oemName,
                     "productName": partNo.toLowerCase(),
                     "version": asset.firmwareVersion,
                     "project":asset.project
                 });
                 if (cve) {
     
                     console.log("cveId already exists");
                 } else {
     
     
     
                     const metrcis = cveData.cve.metrics;
                     let severity = "";
     
                     let cveDataCopy = {
                         ...cveData.cveDetails
                     };
     
                     if (Object.keys(metrcis).length > 0) {
     
     
                         const filteredMetrics = [];
                         Object.keys(metrcis).forEach((key) => {
                             const sortedMetrics = metrcis[key].sort((a, b) => (a.cvssData.baseScore < b.cvssData.baseScore) ? 1 : a.cvssData.baseScore > b.cvssData.baseScore ? -1 : 0);
                             filteredMetrics.push(sortedMetrics[0])
                         })
     
                         const priorityMetric = filteredMetrics.sort((a, b) => (a.cvssData.baseScore < b.cvssData.baseScore) ? 1 : a.cvssData.baseScore > b.cvssData.baseScore ? -1 : 0)[0];
     
                         cveDataCopy = {
                             ...cveDataCopy,
                             metrics: {
                                 [Object.keys(metrcis)[0]]: [{
                                     ...priorityMetric
                                 }]
                             }
                         }
                         severity = priorityMetric.cvssData.baseSeverity ?? priorityMetric.baseSeverity
     
                         let dateVal = cveData.cve.published;
                         let monthYear = dateVal.split("-", 2);
                         let month = monthYear[1];
                         let year = monthYear[0];
                         let saveData = {
                             "vendorName": Product.oemName,
                             "productName": partNo.toLowerCase(),
                             "month": month,
                             "year": year,
                             date: cveData.cve.published,
                             "fix": "N",
                             seviarity: severity,
                             "cveId": cveData.cve.id,
                             "cveDetails": cveData,
                             version: asset.firmwareVersion,
                             "partNo": asset.partNo,
                             "serialNo": asset.serialNo,
                             "osType": asset.osType,
                             "project":asset.project,
                             "type":asset.type
                         };
                         vendorProductCveModel.create(saveData);
                         //}
                     } else {
     
                         // let cve = await vendorProductCveModel.findOne({"cveId":cveData.cve.id});
     
                         // if(cve){
                         //     console.log("cveId already exists");
                         // }else{
                         let dateVal = cveData.cve.published;
                         let monthYear = dateVal.split("-", 2);
                         let month = monthYear[1];
                         let year = monthYear[0];
     
                         let saveData = {
                             "vendorName": Product.oemName,
                             "productName": partNo.toLowerCase(),
                             "month": month,
                             "year": year,
                             date: cveData.cve.published,
                             "fix": "N",
                             seviarity: severity,
                             "cveId": cveData.cve.id,
                             "cveDetails": cveData,
                             version: firmwareVersion,
                             "partNo": asset.partNo,
                             "serialNo": asset.serialNo,
                             "osType": asset.osType,
                             "project":asset.project,
                             "type":asset.type
                         };
                         vendorProductCveModel.create(saveData);
                         //}
     
                     }
                 }
     
     
             });
         }
    })

}

async function processVulnerability(vulnerability, cpeName, cpeCriteria) {

    let parentNode, childrenNode, childrenOrNode;
    let matchedCveIds =[];
    let matchingCriteriaCount = 0;
   

    vulnerability.cve.configurations.forEach((configuration) => {

        let isPush = false;
        let startIncludingEndIncludingCheck = false;
        let startIncludingEndExcludingCheck = false;

        let endExcludingCheck = false;
        let endIncludingCheck = false;
        let versionStartIncluding  = false;

        let parentNodes=[], childrenNodes=[], childrenOrNodes=[];


        if (configuration.nodes && configuration.operator === "AND") {
           // console.log('coming 1')
               
          return   processAndCpeMatches(configuration.nodes,cpeName,parentNodes,childrenNodes,cpeCriteria,isPush,
                    startIncludingEndIncludingCheck,startIncludingEndExcludingCheck,endExcludingCheck,endIncludingCheck,matchingCriteriaCount,matchedCveIds,
                    vulnerability,versionStartIncluding);

                   
            

             
        } else if (configuration.nodes && configuration.operator !== 'AND') {
            //console.log('coming 2')
        
         return processOrCpeMatches(configuration.nodes,cpeName,childrenOrNodes,matchingCriteriaCount,matchedCveIds,vulnerability,
                isPush,startIncludingEndIncludingCheck,startIncludingEndExcludingCheck,endExcludingCheck,endIncludingCheck,versionStartIncluding);

                         
            
        }
    });
    // const configs = vulnerability.cve.configurations
    // for (let index = 0; index < configs.length; index++) {
    //     const configuration = configs[index];
    //     let isPush = false;
    //     let startIncludingEndIncludingCheck = false;
    //     let startIncludingEndExcludingCheck = false;

    //     let endExcludingCheck = false;
    //     let endIncludingCheck = false;



    //     if (configuration.nodes && configuration.operator === "AND") {
    //         console.log('coming 1')
               
    //          processAndCpeMatches(configuration.nodes,cpeName,parentNodes,childrenNodes,cpeCriteria,isPush,
    //                 startIncludingEndIncludingCheck,startIncludingEndExcludingCheck,endExcludingCheck,endIncludingCheck,matchingCriteriaCount,matchedCveIds,vulnerability);

                   
            

             
    //     } else if (configuration.nodes && configuration.operator !== 'AND') {
    //         console.log('coming 2')
        
    //       processOrCpeMatches(configuration.nodes,cpeName,childrenOrNodes,matchingCriteriaCount,matchedCveIds,vulnerability,
    //             isPush,startIncludingEndIncludingCheck,startIncludingEndExcludingCheck,endExcludingCheck,endIncludingCheck);
    //             // return matchedCveIds 
                         
            
    //     }
    // }
    //console.log(matchedCveIds, 'matchedCveIds')
    return matchedCveIds 
}


async function processOrCpeMatches(nodes,cpeName,childrenOrNodes,matchingCriteriaCount,matchedCveIds,vulnerability,
    isPush,startIncludingEndIncludingCheck,startIncludingEndExcludingCheck,endExcludingCheck,endIncludingCheck,versionStartIncluding) {

        

        const cpeVersionSegments = cpeName.split(':');
        //  const cpeLastNumber = cpeVersionSegments[5]




        // const regex = /[^\w\s.]/;

        // let cpeLastNumber = cpeVersionSegments[5];
        // let uniqueLastNumber;
        // if (regex.test(cpeLastNumber)) {
        //     const versionNumberWithSpecialChars = cpeVersionSegments[5];
        //     const match = versionNumberWithSpecialChars.match(/([\d.]+)/);
        //     uniqueLastNumber = match ? match[0] : undefined;
        // } else {
        //     uniqueLastNumber = cpeLastNumber;
        // }

        const regex = /[^\w\s.]/;

        let cpeLastNumber = cpeVersionSegments[5];
        let uniqueLastNumber;
        if (regex.test(cpeLastNumber)) {
            let versionNumberWithSpecialChars = cpeVersionSegments[5];

                 if (versionNumberWithSpecialChars.includes('%5C')) {
                                versionNumberWithSpecialChars = versionNumberWithSpecialChars.replace(/%5C/g, '');
                            }

            const match = versionNumberWithSpecialChars.match(/([\d.]+)\((\d+)\)/);
            if (match) {
                uniqueLastNumber = match[1] + "." + match[2];
            } else {
                uniqueLastNumber = undefined;
            }
        } else {
            uniqueLastNumber = cpeLastNumber;
        }


        const cpeNameSplit = cpeVersionSegments.slice(0, 6).join(':')

        nodes.map(async (node) => {
            node.cpeMatch.map(async (cpeMatch) => {
            
                if(cpeMatch.vulnerable){

                            const cpeVendorOsType = cpeName.split(':');
                            const cveVendorOsType = cpeMatch.criteria.split(':');

                            if (cveVendorOsType[3] == cpeVendorOsType[3] && cveVendorOsType[4] == cpeVendorOsType[4]) {
                                childrenOrNodes.push({cpeMatch});
                            }
                        }   

            })
        })

        // await Promise.all(nodes.map(async (node) => {
        //     await Promise.all(node.cpeMatch.map(async (cpeMatch) => {
            
        //         if(cpeMatch.vulnerable){

        //                     const cpeVendorOsType = cpeName.split(':');
        //                     const cveVendorOsType = cpeMatch.criteria.split(':');

        //                     if (cveVendorOsType[3] == cpeVendorOsType[3] && cveVendorOsType[4] == cpeVendorOsType[4]) {
        //                         childrenOrNodes.push({cpeMatch});
        //                     }
        //                 }   

        //     }));
        // }));

        childrenOrNodes.some((childrenOrNode) => {


            let startIncludingEndIncludingCheck = false;
            let startIncludingEndExcludingCheck = false;
    
            let endExcludingCheck = false;
            let endIncludingCheck = false;
            let versionStartIncluding  = false;

            const cpeSegments = childrenOrNode.cpeMatch.criteria.split(':');

            let cpeMatchFirstFive = cpeSegments.slice(0, 6).join(':');

            if (cpeMatchFirstFive.includes('\\')) {
                cpeMatchFirstFive = cpeMatchFirstFive.replace(/\\/g, '%5C');
            }
           
            
            
            if ( childrenOrNode.cpeMatch.versionEndExcluding && childrenOrNode.cpeMatch.versionStartIncluding) {

                if (childrenOrNode.cpeMatch.versionStartIncluding.includes('\\')) {
                    childrenOrNode.cpeMatch.versionStartIncluding = childrenOrNode.cpeMatch.versionStartIncluding.replace(/\\/g, '');
                }

                if (childrenOrNode.cpeMatch.versionEndExcluding.includes('\\')) {
                    childrenOrNode.cpeMatch.versionEndExcluding = childrenOrNode.cpeMatch.versionEndExcluding.replace(/\\/g, '');
                }
                startIncludingEndExcludingCheck = true;
            }
           else  if (  !startIncludingEndExcludingCheck && childrenOrNode.cpeMatch.versionEndIncluding && childrenOrNode.cpeMatch.versionStartIncluding) {
               
                if (childrenOrNode.cpeMatch.versionEndIncluding.includes('\\')) {
                    childrenOrNode.cpeMatch.versionEndIncluding = childrenOrNode.cpeMatch.versionEndIncluding.replace(/\\/g, '');
                }
               
                if (childrenOrNode.cpeMatch.versionStartIncluding.includes('\\')) {
                    childrenOrNode.cpeMatch.versionStartIncluding = childrenOrNode.cpeMatch.versionStartIncluding.replace(/\\/g, '');
                }
                startIncludingEndIncludingCheck = true;
            }

            else if ( !startIncludingEndExcludingCheck && !startIncludingEndIncludingCheck && 
                childrenOrNode.cpeMatch.versionEndExcluding) {
               
                if (childrenOrNode.cpeMatch.versionEndExcluding.includes('\\')) {
                    childrenOrNode.cpeMatch.versionEndExcluding = childrenOrNode.cpeMatch.versionEndExcluding.replace(/\\/g, '');
                }
                endExcludingCheck = true;
            }

            else if (  !startIncludingEndExcludingCheck && !startIncludingEndIncludingCheck && 
                !endExcludingCheck&& childrenOrNode.cpeMatch.versionEndIncluding) {
               
                if (childrenOrNode.cpeMatch.versionEndIncluding.includes('\\')) {
                    childrenOrNode.cpeMatch.versionEndIncluding = childrenOrNode.cpeMatch.versionEndIncluding.replace(/\\/g, '');
                }
                endIncludingCheck = true;
            }

          else  if (  !startIncludingEndExcludingCheck && !startIncludingEndIncludingCheck && 
                !endExcludingCheck && !endIncludingCheck  && childrenOrNode.cpeMatch.versionStartIncluding) {
               
                if (childrenOrNode.cpeMatch.versionStartIncluding.includes('\\')) {
                    childrenOrNode.cpeMatch.versionStartIncluding = childrenOrNode.cpeMatch.versionStartIncluding.replace(/\\/g, '');
                }
                versionStartIncluding = true;
            }
            
        //     if(!startIncludingEndExcludingCheck && !endIncludingCheck && !endExcludingCheck && 
        //         !startIncludingEndIncludingCheck ){
        //             isPush = true;
        //         }
        //    else  
      
           if (cpeNameSplit === cpeMatchFirstFive) {
                isPush = true;
            }
 

            else if (versionStartIncluding  && isVersionGreaterThanOrEqualTo(uniqueLastNumber,childrenOrNode.cpeMatch.versionStartIncluding)) {
             
                isPush = true;
            } 

            else if (!versionStartIncluding && startIncludingEndIncludingCheck && 
                isVersionGreaterThanOrEqualTo(uniqueLastNumber , childrenOrNode.cpeMatch.versionStartIncluding) &&
               isVersionLessThanOrEqualTo(  uniqueLastNumber ,childrenOrNode.cpeMatch.versionEndIncluding)) {

                isPush = true;
             

            } else if (!versionStartIncluding && !startIncludingEndIncludingCheck && startIncludingEndExcludingCheck && 
                isVersionGreaterThanOrEqualTo(uniqueLastNumber , childrenOrNode.cpeMatch.versionStartIncluding) &&
                 isVersionLessThanOrEqualTo(  uniqueLastNumber ,childrenOrNode.cpeMatch.versionEndExcluding)) {

                    isPush = true;

            }

            else if ( !versionStartIncluding && !startIncludingEndIncludingCheck && !startIncludingEndExcludingCheck && !endExcludingCheck &&
                endIncludingCheck &&  isVersionLessThanOrEqualTo(  uniqueLastNumber ,childrenOrNode.cpeMatch.versionEndIncluding)) {
              
                    isPush = true;

            }
            
            else if (endExcludingCheck && isVersionLessThan(uniqueLastNumber, childrenOrNode.cpeMatch.versionEndExcluding)) {
             
                isPush = true;
            } 
            
           
      
            if(isPush){

                matchingCriteriaCount++;
                matchedCveIds.push(vulnerability);
              //  console.log("vulnerability", vulnerability, matchedCveIds)
                return matchedCveIds

            }

        });



    }



async function processAndCpeMatches(nodes,cpeName,parentNodes,childrenNodes,cpeCriteria,isPush,
    startIncludingEndIncludingCheck,startIncludingEndExcludingCheck,endExcludingCheck,endIncludingCheck,matchingCriteriaCount,
    matchedCveIds,vulnerability,versionStartIncluding) {

nodes.map(async (node) => {
    node.cpeMatch.map(async (cpeMatch) => {
        if (cpeMatch.vulnerable) {
            const cpeVendorOsType = cpeName.split(':');
            const cveVendorOsType = cpeMatch.criteria.split(':');

            if (cveVendorOsType[3] == cpeVendorOsType[3] && cveVendorOsType[4] == cpeVendorOsType[4]) {
                parentNodes.push({ cpeMatch });
            }
        } else {
            childrenNodes.push({ cpeMatch });
        }
    });
});

    // Now that parentNodes is populated, iterate over it
    parentNodes.some((parentNode) => {
        
       
                   let  isChildNodeExist= false;
                   let startIncludingEndIncludingCheck = false;
                   let startIncludingEndExcludingCheck = false;
           
                   let endExcludingCheck = false;
                   let endIncludingCheck = false;
                   let versionStartIncluding  = false;
                 
                   
                    if (  parentNode.cpeMatch.versionEndExcluding && parentNode.cpeMatch.versionStartIncluding) {

                        if (parentNode.cpeMatch.versionStartIncluding.includes('\\')) {
                            parentNode.cpeMatch.versionStartIncluding = parentNode.cpeMatch.versionStartIncluding.replace(/\\/g, '');
                        }

                        if (parentNode.cpeMatch.versionEndExcluding.includes('\\')) {
                            parentNode.cpeMatch.versionEndExcluding = parentNode.cpeMatch.versionEndExcluding.replace(/\\/g, '');
                        }
                        startIncludingEndExcludingCheck = true;
                    }
                    else if (!startIncludingEndExcludingCheck && parentNode.cpeMatch.versionEndIncluding && parentNode.cpeMatch.versionStartIncluding) {
                       
                        if (parentNode.cpeMatch.versionEndIncluding.includes('\\')) {
                            parentNode.cpeMatch.versionEndIncluding = parentNode.cpeMatch.versionEndIncluding.replace(/\\/g, '');
                        }
                       
                        if (parentNode.cpeMatch.versionStartIncluding.includes('\\')) {
                            parentNode.cpeMatch.versionStartIncluding = parentNode.cpeMatch.versionStartIncluding.replace(/\\/g, '');
                        }
                        startIncludingEndIncludingCheck = true;
                    }

                    else if ( !startIncludingEndExcludingCheck && !startIncludingEndIncludingCheck && 
                        parentNode.cpeMatch.versionEndExcluding) {
                       
                        if (parentNode.cpeMatch.versionEndExcluding.includes('\\')) {
                            parentNode.cpeMatch.versionEndExcluding = parentNode.cpeMatch.versionEndExcluding.replace(/\\/g, '');
                        }
                        endExcludingCheck = true;
                    }

                   else  if ( !startIncludingEndExcludingCheck && !startIncludingEndIncludingCheck && 
                        !endExcludingCheck&& parentNode.cpeMatch.versionEndIncluding) {
                       
                        if (parentNode.cpeMatch.versionEndIncluding.includes('\\')) {
                            parentNode.cpeMatch.versionEndIncluding = parentNode.cpeMatch.versionEndIncluding.replace(/\\/g, '');
                        }
                        endIncludingCheck = true;
                    }

                  else  if ( !startIncludingEndExcludingCheck && !startIncludingEndIncludingCheck && 
                        !endExcludingCheck&& !endIncludingCheck &&  parentNode.cpeMatch.versionStartIncluding) {
                
                        if (parentNode.cpeMatch.versionStartIncluding.includes('\\')) {
                            parentNode.cpeMatch.versionStartIncluding = parentNode.cpeMatch.versionStartIncluding.replace(/\\/g, '');
                        }
                        versionStartIncluding = true;
                    }

                    const cpeVendorOsType = cpeName.split(':');
                    const cveVendorOsType = parentNode.cpeMatch.criteria.split(':');
                   
                     const cpeNameSplit = cpeVendorOsType.slice(0, 6).join(':')
                     let parentCpeMatchFirstFive = cveVendorOsType.slice(0, 6).join(':');
                     const segments = parentCpeMatchFirstFive.split(':');


                    //  const regex = /[^\w\s.]/;

                    //     let cpeLastNumber = cpeVendorOsType[5];
                    //     let uniqueLastNumber;
                    //     if (regex.test(cpeLastNumber)) {
                    //         const versionNumberWithSpecialChars = cpeVendorOsType[5];
                    //         const match = versionNumberWithSpecialChars.match(/([\d.]+)/);
                    //         uniqueLastNumber = match ? match[0] : undefined;
                    //     } else {
                    //         uniqueLastNumber = cpeLastNumber;
                    //     }
                    

                    const regex = /[^\w\s.]/;

                            let cpeLastNumber = cpeVendorOsType[5];
                            let uniqueLastNumber;
                            if (regex.test(cpeLastNumber)) {
                                let versionNumberWithSpecialChars = cpeVendorOsType[5];

                                     if (versionNumberWithSpecialChars.includes('%5C')) {
                                                    versionNumberWithSpecialChars = versionNumberWithSpecialChars.replace(/%5C/g, '');
                                                }

                                const match = versionNumberWithSpecialChars.match(/([\d.]+)\((\d+)\)/);
                                if (match) {
                                    uniqueLastNumber = match[1] + "." + match[2];
                                } else {
                                    uniqueLastNumber = undefined;
                                }
                            } else {
                                uniqueLastNumber = cpeLastNumber;
                            }

                        if (parentCpeMatchFirstFive.includes('\\')) {
                            parentCpeMatchFirstFive = parentCpeMatchFirstFive.replace(/\\/g, '%5C');
                        }


                        if(!startIncludingEndExcludingCheck && !endIncludingCheck && !endExcludingCheck && 
                            !startIncludingEndIncludingCheck && !versionStartIncluding &&  childrenNodes && childrenNodes.length == 0){
                                matchingCriteriaCount++;
                                matchedCveIds.push(vulnerability);
                        }
                      

                        else  if (cpeNameSplit === parentCpeMatchFirstFive) {

                            if (childrenNodes && childrenNodes.length > 0) {

                                isChildNodeExist = true;
                                childrenNodes.forEach((childNode) => {
                                    
                                    if (childNode.cpeMatch.criteria === cpeCriteria) {
                                        
                                        matchingCriteriaCount++;
                                        matchedCveIds.push(vulnerability);
                                        
                                    }
                                    if (
                                        childNode.cpeMatch.criteria === cpeCriteria &&
                                        uniqueLastNumber &&
                                        childNode.cpeMatch.versionStartIncluding &&
                                        childNode.cpeMatch.versionEndExcluding &&
                                       isVersionGreaterThanOrEqualTo( uniqueLastNumber , childNode.cpeMatch.versionStartIncluding) &&
                                        isVersionLessThan(uniqueLastNumber , childNode.cpeMatch.versionEndExcluding)
                                    ) {
                                        matchingCriteriaCount++;
                                        matchedCveIds.push(vulnerability);
                                    }
                                    if (
                                        childNode.cpeMatch.criteria === cpeCriteria &&
                                        uniqueLastNumber &&
                                        uniqueLastNumber <= childNode.cpeMatch.versionEndExcluding
                                    ) {
                                        matchingCriteriaCount++;
                                        matchedCveIds.push(vulnerability);
                                    }
                                });
                            }
                            
                        }

                        else if (!startIncludingEndExcludingCheck && !endIncludingCheck && !endExcludingCheck && 
                            !startIncludingEndIncludingCheck && !versionStartIncluding &&  childrenNodes && childrenNodes.length > 0){
                                const parentCpeMatchFirstFiveCHeck = parentCpeMatchFirstFive.split(':');
                                if (parentCpeMatchFirstFiveCHeck[5]  =='-' || parentCpeMatchFirstFiveCHeck[5]  =='-') {

                                    isChildNodeExist = true;
                                    childrenNodes.forEach((childCpeMatch) => {
                                        if (childCpeMatch.cpeMatch.criteria === cpeCriteria) {
                                            isPush = true;
                                        }
                                    });
                                }
                                
                        }

                        else if (versionStartIncluding  &&
                             isVersionGreaterThanOrEqualTo(uniqueLastNumber,parentNode.cpeMatch.versionStartIncluding)) {
             
                                if (childrenNodes && childrenNodes.length > 0) {

                                    isChildNodeExist = true;
                                    childrenNodes.forEach((childCpeMatch) => {
                                        if (childCpeMatch.cpeMatch.criteria === cpeCriteria) {
                                            isPush = true;
                                        }
                                    });
                                }else{
                                    isPush = true;
                                }
                        }

                        else if (startIncludingEndIncludingCheck && 
                            isVersionGreaterThanOrEqualTo(uniqueLastNumber , parentNode.cpeMatch.versionStartIncluding) &&
                           isVersionLessThanOrEqualTo(  uniqueLastNumber ,parentNode.cpeMatch.versionEndIncluding)) {

                            if (childrenNodes && childrenNodes.length > 0) {

                                isChildNodeExist = true;
                                childrenNodes.forEach((childCpeMatch) => {
                                    if (childCpeMatch.cpeMatch.criteria === cpeCriteria) {
                                        isPush = true;
                                    }
                                });
                            }else{
                                isPush = true;
                            }

                        } else if (!startIncludingEndIncludingCheck && startIncludingEndExcludingCheck && 
                            isVersionGreaterThanOrEqualTo(uniqueLastNumber , parentNode.cpeMatch.versionStartIncluding) &&
                             isVersionLessThanOrEqualTo(  uniqueLastNumber ,parentNode.cpeMatch.versionEndExcluding)) {

                                if (childrenNodes && childrenNodes.length > 0) {

                                    isChildNodeExist = true;
                                    childrenNodes.forEach((childCpeMatch) => {
                                        if (childCpeMatch.cpeMatch.criteria === cpeCriteria) {
                                            isPush = true;
                                        }
                                    });
                                }else{
                                    isPush = true;
                                }

                        }

                        else if ( !startIncludingEndIncludingCheck && !startIncludingEndExcludingCheck && !endExcludingCheck &&
                            endIncludingCheck &&  isVersionLessThanOrEqualTo(  uniqueLastNumber ,parentNode.cpeMatch.versionEndIncluding)) {
                          
                                if (childrenNodes && childrenNodes.length > 0) {

                                    isChildNodeExist = true;
                                    childrenNodes.forEach((childCpeMatch) => {
                                        if (childCpeMatch.cpeMatch.criteria === cpeCriteria) {
                                            isPush = true;
                                        }
                                    });
                                }else{
                                    isPush = true;
                                }

                        }
                        
                        else if ( endExcludingCheck && isVersionLessThan(uniqueLastNumber, parentNode.cpeMatch.versionEndExcluding)) {

                            if (childrenNodes && childrenNodes.length > 0) {

                                isChildNodeExist = true;
                                childrenNodes.forEach((childCpeMatch) => {
                                    if (childCpeMatch.cpeMatch.criteria === cpeCriteria) {
                                        isPush = true;
                                    }
                                });
                            }else{
                                isPush = true;
                            }


                        } 
                        
                        // else if ( isChildNodeExist && startIncludingEndIncludingCheck && isVersionGreaterThanOrEqualTo(uniqueLastNumber , parentNode.cpeMatch.versionStartIncluding ) 
                        //             && isVersionLessThanOrEqualTo(  uniqueLastNumber ,parentNode.cpeMatch.versionEndIncluding) ) {

                        //     isPush = true;
                        // } else if (isChildNodeExist && !startIncludingEndIncludingCheck && startIncludingEndExcludingCheck && isVersionGreaterThanOrEqualTo(uniqueLastNumber , parentNode.cpeMatch.versionStartIncluding)
                        //     &&  isVersionLessThanOrEqualTo(  uniqueLastNumber ,parentNode.cpeMatch.versionEndExcluding)  ) {
                        //     isPush = true;

                        // } else if (isChildNodeExist && !startIncludingEndIncludingCheck && !startIncludingEndExcludingCheck && endExcludingCheck &&
                        //     isVersionLessThan(uniqueLastNumber, parentNode.cpeMatch.versionEndExcluding)) {
                        //     isPush = true;

                        // }


                        // else if ( isChildNodeExist && !startIncludingEndIncludingCheck && !startIncludingEndExcludingCheck && !endExcludingCheck && 
                        //     endIncludingCheck && isVersionLessThanOrEqualTo(  uniqueLastNumber ,parentNode.cpeMatch.versionEndIncluding) ) {
                        //         isPush = true;
                        // }

                        if (isPush) {
                            matchingCriteriaCount++;
                            matchedCveIds.push(vulnerability);
                        }
        

    });
}

function isVersionLessThan(version1, version2) {

    version2 = removechars(version2);
    version1 = removechars(version1);


    const v1 = version1.split('.').map(Number);
    const v2 = version2?.split('.').map(Number);

    for (let i = 0; i < Math.max(v1.length, v2?.length); i++) {
        const num1 = v1[i] || 0;
        const num2 = v2[i] || 0;

        if (num1 > num2) {
            return false;
        } else if (num1 < num2) {
            return true;
        }
    }

    return false;
}

function removechars(ver) {

    let version = ver;

    if(version  != undefined ){

        if( version.includes('\\')){
         version = version.replace(/\\/g, '');
        }

    version = version.replace(/[a-zA-Z]/g, "");
    version = version.replace(/\(|\)/g, ".");
    }
    return version;
}




function isVersionGreaterThan(version1,version2) {

    return !isVersionLessThan(version1,version2)
}


function isVersionLessThanOrEqualTo(version1, version2) {

    if(version2 && version2!=undefined && version1 && version1 !=undefined){
    
    version2 = removechars(version2);
    version1 = removechars(version1);

    const v1 = version1.split('.').map(Number);
    const v2 = version2?.split('.').map(Number);

    

    for (let i = 0; i < Math.max(v1.length, v2?.length); i++) {
        const num1 = v1[i] || 0;
        const num2 = v2[i] || 0;
        if (num1 > num2) {
            return false;
        } else if (num1 < num2) {
            return true;
        }
    }
    return true;
}
    return false;
}


function isVersionGreaterThanOrEqualTo(version1, version2) {

if(version2 && version2!=undefined && version1 && version1 !=undefined){

    version2 = removechars(version2);
    version1 = removechars(version1);
    
    const v1 = version1.split('.').map(Number);
    const v2 = version2?.split('.').map(Number);
   
    for (let i = 0; i < Math.max(v1.length, v2?.length); i++) {
        const num1 = v1[i] || 0;
        const num2 = v2[i] || 0;
        if(num1 < num2) {
            return false;
        } else if(num1 > num2) {
            return true;
        }
    }
   return true; 

}
return false; 
    
}




export default RunAssetProductCveMappingScheduler;